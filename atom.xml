<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeePeng&#39;s blog</title>
  
  <subtitle>Quick notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.leepeng..top/"/>
  <updated>2018-01-21T10:18:08.256Z</updated>
  <id>http://www.leepeng..top/</id>
  
  <author>
    <name>LeePeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>倒计时效果</title>
    <link href="http://www.leepeng..top/2017/08/06/countdown/"/>
    <id>http://www.leepeng..top/2017/08/06/countdown/</id>
    <published>2017-08-05T16:00:00.000Z</published>
    <updated>2018-01-21T10:18:08.256Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/time.jpg" class="full-image"></p><p>当前时间</p><p><div id="time"></div><br>倒计时1</p><p><div class="dao1">距离设置时间还有<span id="dao1"></span>天</div><br>倒计时2 </p><p><div class="dao2">距离设置时间2019/1/1,00:00:00还有<span id="dao2"></span></div></p><script>    window.onload= function () {        showtime();        dao1();        dao2();    }    function formatTime(i){        if(i<10){            i='0'+i;        }        return i;    }    //当前时间    function showtime(){        let myDate = new Date();        let year = myDate.getFullYear();//年        let month = myDate.getMonth();//月        let date = myDate.getDate();//日        let day = myDate.getDay();//星期        let h = myDate.getHours();//时        let m = myDate.getMinutes();//分        let s = myDate.getSeconds();//秒            m = formatTime(m);            s = formatTime(s);        let time=document.getElementById("time");        let weekday = ['星期日','星期一','星期二','星期三','星期四','星期五','星期六','']            time.innerHTML=year+'年'+(month+1)+'月'+date+'日 '+weekday[day]+' '+h+':'+m+':'+s;        setTimeout(showtime,500);    }    //当前时间    //倒计时1    function dao1(){        let curtime = new Date();        let endtime = new Date("2019,1,1");        let time = endtime.getTime() - curtime.getTime();//getTime()毫秒        //1000 * 60 * 60 * 24一天的秒数        //利用Math.ceil()对象方法，对得出的时间差进行向上取整。        //parseInt()取整。        daytime = parseInt(time/(1000 * 60 * 60 * 24))        if(daytime > 0 ){          document.getElementById('dao1').innerHTML = daytime;        }    }    //倒计时1    //倒计时2    function dao2(){        let nowtime = new Date();        let endtime = new Date("2019/1/1,00:00:00");        let time = parseInt((endtime.getTime() - nowtime.getTime())/1000);//秒        let d = parseInt(time/(24*60*60));        let h = parseInt(time/(60*60)%24);        let m = parseInt(time/60%60);        let s = parseInt(time%60);            m = formatTime(m);            s = formatTime(s);        document.getElementById('dao2').innerHTML = d+'天'+h+'时'+m+'分'+s+'秒';        setTimeout(dao2,500)    }</script><blockquote><p>代码</p></blockquote><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;当前时间&lt;/p&gt;</span><br><span class="line">&lt;div id=<span class="string">"time"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;p&gt;倒计时1&lt;/p&gt;</span><br><span class="line">&lt;div class=<span class="string">"dao1"</span>&gt;距离设置时间还有&lt;span id=<span class="string">"dao1"</span>&gt;&lt;/span&gt;天&lt;/div&gt;</span><br><span class="line">&lt;p&gt;倒计时2&lt;/p&gt;</span><br><span class="line">&lt;div class=<span class="string">"dao2"</span>&gt;距离设置时间2019/1/1,00:00:00还有&lt;span id=<span class="string">"dao2"</span>&gt;&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">window.onload= <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">showtime();</span><br><span class="line">dao1();</span><br><span class="line">dao2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> formatTime(i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;10)&#123;</span><br><span class="line">i=<span class="string">'0'</span>+i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">//当前时间</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">showtime</span></span>()&#123;</span><br><span class="line"><span class="built_in">let</span> myDate = new Date();</span><br><span class="line"><span class="built_in">let</span> year = myDate.getFullYear();//年</span><br><span class="line"><span class="built_in">let</span> month = myDate.getMonth();//月</span><br><span class="line"><span class="built_in">let</span> date = myDate.getDate();//日</span><br><span class="line"><span class="built_in">let</span> day = myDate.getDay();//星期</span><br><span class="line"><span class="built_in">let</span> h = myDate.getHours();//时</span><br><span class="line"><span class="built_in">let</span> m = myDate.getMinutes();//分</span><br><span class="line"><span class="built_in">let</span> s = myDate.getSeconds();//秒</span><br><span class="line">m = formatTime(m);</span><br><span class="line">s = formatTime(s);</span><br><span class="line"><span class="built_in">let</span> time=document.getElementById(<span class="string">"time"</span>);</span><br><span class="line"><span class="built_in">let</span> weekday = [<span class="string">'星期日'</span>,<span class="string">'星期一'</span>,<span class="string">'星期二'</span>,<span class="string">'星期三'</span>,<span class="string">'星期四'</span>,<span class="string">'星期五'</span>,<span class="string">'星期六'</span>,<span class="string">''</span>]</span><br><span class="line">time.innerHTML=year+<span class="string">'年'</span>+month+<span class="string">'月'</span>+date+<span class="string">'日 '</span>+weekday[day]+<span class="string">' '</span>+h+<span class="string">':'</span>+m+<span class="string">':'</span>+s;</span><br><span class="line">setTimeout(showtime,500);</span><br><span class="line">&#125;</span><br><span class="line">//当前时间</span><br><span class="line">//倒计时1</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">dao1</span></span>()&#123;</span><br><span class="line"><span class="built_in">let</span> curtime = new Date();</span><br><span class="line"><span class="built_in">let</span> endtime = new Date(<span class="string">"2019,1,1"</span>);</span><br><span class="line"><span class="built_in">let</span> time = endtime.getTime() - curtime.getTime();//getTime()毫秒</span><br><span class="line">//1000 * 60 * 60 * 24一天的秒数</span><br><span class="line">//利用Math.ceil()对象方法，对得出的时间差进行向上取整。</span><br><span class="line">//parseInt()取整。</span><br><span class="line">daytime = parseInt(time/(1000 * 60 * 60 * 24))</span><br><span class="line"><span class="keyword">if</span>(daytime &gt; 0 )&#123;</span><br><span class="line">      document.getElementById(<span class="string">'dao1'</span>).innerHTML = daytime;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//倒计时1</span><br><span class="line">//倒计时2</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">dao2</span></span>()&#123;</span><br><span class="line"><span class="built_in">let</span> nowtime = new Date();</span><br><span class="line"><span class="built_in">let</span> endtime = new Date(<span class="string">"2019/1/1,00:00:00"</span>);</span><br><span class="line"><span class="built_in">let</span> time = parseInt((endtime.getTime() - nowtime.getTime())/1000);//秒</span><br><span class="line"><span class="built_in">let</span> d = parseInt(time/(24*60*60));</span><br><span class="line"><span class="built_in">let</span> h = parseInt(time/(60*60)%24);</span><br><span class="line"><span class="built_in">let</span> m = parseInt(time/60%60);</span><br><span class="line"><span class="built_in">let</span> s = parseInt(time%60);</span><br><span class="line">m = formatTime(m);</span><br><span class="line">s = formatTime(s);</span><br><span class="line">document.getElementById(<span class="string">'dao2'</span>).innerHTML = d+<span class="string">'天'</span>+h+<span class="string">'时'</span>+m+<span class="string">'分'</span>+s+<span class="string">'秒'</span>;</span><br><span class="line">setTimeout(dao2,500)</span><br><span class="line">&#125;</span><br><span class="line">//倒计时2</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/time.jpg&quot; class=&quot;full-image&quot;&gt;&lt;/p&gt;
&lt;p&gt;当前时间&lt;/p&gt;
&lt;p&gt;&lt;div id=&quot;time&quot;&gt;&lt;/div&gt;&lt;br&gt;倒计时1&lt;/p&gt;
&lt;p&gt;&lt;div class=&quot;dao1&quot;&gt;距离设置时间还有&lt;span id=&quot;dao1&quot;&gt;&lt;/span&gt;天&lt;/div&gt;&lt;br&gt;倒计时2 &lt;/p&gt;
&lt;p&gt;&lt;div class=&quot;dao2&quot;&gt;距离设置时间2019/1/1,00:00:00还有&lt;span id=&quot;dao2&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;/p&gt;
&lt;script&gt;
    window.onload= function () {
        showtime();
        dao1();
        dao2();
    }
    function formatTime(i){
        if(i&lt;10){
            i=&#39;0&#39;+i;
        }
        return i;
    }
    //当前时间
    function showtime(){
        let myDate = new Date();
        let year = myDate.getFullYear();//年
        let month = myDate.getMonth();//月
        let date = myDate.getDate();//日
        let day = myDate.getDay();//星期
        let h = myDate.getHours();//时
        let m = myDate.getMinutes();//分
        let s = myDate.getSeconds();//秒
            m = formatTime(m);
            s = formatTime(s);
        let time=document.getElementById(&quot;time&quot;);
        let weekday = [&#39;星期日&#39;,&#39;星期一&#39;,&#39;星期二&#39;,&#39;星期三&#39;,&#39;星期四&#39;,&#39;星期五&#39;,&#39;星期六&#39;,&#39;&#39;]
            time.innerHTML=year+&#39;年&#39;+(month+1)+&#39;月&#39;+date+&#39;日 &#39;+weekday[day]+&#39; &#39;+h+&#39;:&#39;+m+&#39;:&#39;+s;
        setTimeout(showtime,500);
    }
    //当前时间
    //倒计时1
    function dao1(){
        let curtime = new Date();
        let endtime = new Date(&quot;2019,1,1&quot;);
        let time = endtime.getTime() - curtime.getTime();//getTime()毫秒
        //1000 * 60 * 60 * 24一天的秒数
        //利用Math.ceil()对象方法，对得出的时间差进行向上取整。
        //parseInt()取整。
        daytime = parseInt(time/(1000 * 60 * 60 * 24))
        if(daytime &gt; 0 ){
          document.getElementById(&#39;dao1&#39;).innerHTML = daytime;
        }
    }
    //倒计时1
    //倒计时2
    function dao2(){
        let nowtime = new Date();
        let endtime = new Date(&quot;2019/1/1,00:00:00&quot;);
        let time = parseInt((endtime.getTime() - nowtime.getTime())/1000);//秒
        let d = parseInt(time/(24*60*60));
        let h = parseInt(time/(60*60)%24);
        let m = parseInt(time/60%60);
        let s = parseInt(time%60);
            m = formatTime(m);
            s = formatTime(s);
        document.getElementById(&#39;dao2&#39;).innerHTML = d+&#39;天&#39;+h+&#39;时&#39;+m+&#39;分&#39;+s+&#39;秒&#39;;
        setTimeout(dao2,500)
    }


&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;代码&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://www.leepeng..top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ES6-set-map</title>
    <link href="http://www.leepeng..top/2017/08/05/2017-08-05-es6-set/"/>
    <id>http://www.leepeng..top/2017/08/05/2017-08-05-es6-set/</id>
    <published>2017-08-04T16:00:00.000Z</published>
    <updated>2018-01-21T14:08:54.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。开发中用于去除重复数据<br>Set 本身是一个构造函数，用来生成 Set 数据结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const s = new Set();</span><br><span class="line">[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));</span><br><span class="line">for (let i of s) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// 2 3 5 4</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>Set 方法 </p></blockquote><p>1、新建new Set([‘…’])<br>2、获取个数.size<br>3、添加add、删除delete、是否包含has、清除clear<br>4、keys和values都是相等的<br>5、类似于数组没有重复的元素（唯一的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let s=new Set([1,2,3,3]);</span><br><span class="line">console.log(&quot;arr:&quot;,arr) // 返回1,2,3 去除重复数据</span><br><span class="line">s.add(4).add(4) // 注意4被加入了两次</span><br><span class="line">s.delete(2)</span><br><span class="line">console.log(&quot;s:&quot;,s.has(4)) // true</span><br><span class="line">console.log(&quot;s:&quot;,s.keys())</span><br><span class="line">console.log(&quot;s:&quot;,s.values())</span><br><span class="line">s.clear()</span><br></pre></td></tr></table></figure><p>下面是一个对比，看看在判断是否包括一个键上面，Object结构和Set结构的写法不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 对象的写法</span><br><span class="line">const properties = &#123;</span><br><span class="line">  &apos;width&apos;: 1,</span><br><span class="line">  &apos;height&apos;: 1</span><br><span class="line">&#125;;</span><br><span class="line">if (properties[someName]) &#123;</span><br><span class="line">  // do something</span><br><span class="line">&#125;</span><br><span class="line">// Set的写法</span><br><span class="line">const properties = new Set();</span><br><span class="line">properties.add(&apos;width&apos;);</span><br><span class="line">properties.add(&apos;height&apos;);</span><br><span class="line">if (properties.has(someName)) &#123;</span><br><span class="line">  // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Array.from方法可以将 Set 结构转为数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const items = new Set([1, 2, 3, 4, 5]);</span><br><span class="line">const array = Array.from(items);</span><br></pre></td></tr></table></figure><p>这就提供了去除数组重复成员的另一种方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function dedupe(array) &#123;</span><br><span class="line">  return Array.from(new Set(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dedupe([1, 1, 2, 3]) // [1, 2, 3]</span><br></pre></td></tr></table></figure><blockquote><p>遍历操作</p></blockquote><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。<br>    keys()：返回键名的遍历器<br>    values()：返回键值的遍历器<br>    entries()：返回键值对的遍历器<br>    forEach()：使用回调函数遍历每个成员</p><p>keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);</span><br><span class="line"></span><br><span class="line">for (let item of set.keys()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br><span class="line"></span><br><span class="line">for (let item of set.values()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br><span class="line"></span><br><span class="line">for (let item of set.entries()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">// [&quot;red&quot;, &quot;red&quot;]</span><br><span class="line">// [&quot;green&quot;, &quot;green&quot;]</span><br><span class="line">// [&quot;blue&quot;, &quot;blue&quot;]</span><br></pre></td></tr></table></figure><p>直接用for…of循环遍历 Set。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);</span><br><span class="line">for (let x of set) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br></pre></td></tr></table></figure><p>forEach方法，用于对每个成员执行某种操作，没有返回值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set = new Set([1, 4, 9]);</span><br><span class="line">set.forEach((value, key) =&gt; console.log(key + &apos; : &apos; + value))</span><br><span class="line">// 1 : 1</span><br><span class="line">// 4 : 4</span><br><span class="line">// 9 : 9</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。<br>1、新建new Map([])<br>2、 size:属性返回 Map 结构的成员总数<br>    set(key, value):添加一个新建元素到映射。<br>    get(key):返回映射中的指定元素。<br>    has(key):如果映射包含指定元素，则返回 true。<br>    delete(key):从映射中移除指定的元素。<br>    clear:从映射中移除所有元素。<br>    forEach:对映射中的每个元素执行指定操作。<br>    toString:返回映射的字符串表示形式。<br>    valueOf:返回指定对象的原始值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">    [&apos;name&apos;,&apos;leepeng&apos;],</span><br><span class="line">    [&apos;age&apos;,24],</span><br><span class="line">    [&apos;sex&apos;,&apos;男&apos;],</span><br><span class="line">    [obj1,&apos;sfsfdsfe&apos;],</span><br><span class="line">    [obj2,&apos;lihfksdnsiu&apos;],</span><br><span class="line">    [[1,2,3],&apos;haha&apos;]</span><br><span class="line">])</span><br><span class="line">map.set(&apos;friends&apos;,[&apos;ffff&apos;,&apos;gggg&apos;])</span><br><span class="line">console.log(map.size)</span><br><span class="line">console.log(map)</span><br><span class="line">console.log(map.get(&apos;name&apos;))</span><br><span class="line">console.log(map.delete(&apos;name&apos;))</span><br><span class="line">console.log(map.has(&apos;age&apos;))</span><br><span class="line">//map.clear();</span><br><span class="line">console.log(map)</span><br><span class="line">map.forEach(function (value,index) &#123;</span><br><span class="line">    console.log(index+&apos;:&apos;+value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><blockquote><p>遍历方法</p></blockquote><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。<br>keys()：返回键名的遍历器。<br>values()：返回键值的遍历器。<br>entries()：返回所有成员的遍历器。<br>forEach()：遍历 Map 的所有成员。<br>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">  [&apos;F&apos;, &apos;no&apos;],</span><br><span class="line">  [&apos;T&apos;,  &apos;yes&apos;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">for (let key of map.keys()) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;F&quot;</span><br><span class="line">// &quot;T&quot;</span><br><span class="line"></span><br><span class="line">for (let value of map.values()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;no&quot;</span><br><span class="line">// &quot;yes&quot;</span><br><span class="line"></span><br><span class="line">for (let item of map.entries()) &#123;</span><br><span class="line">  console.log(item[0], item[1]);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;F&quot; &quot;no&quot;</span><br><span class="line">// &quot;T&quot; &quot;yes&quot;</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">for (let [key, value] of map.entries()) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;F&quot; &quot;no&quot;</span><br><span class="line">// &quot;T&quot; &quot;yes&quot;</span><br><span class="line"></span><br><span class="line">// 等同于使用map.entries()</span><br><span class="line">for (let [key, value] of map) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;F&quot; &quot;no&quot;</span><br><span class="line">// &quot;T&quot; &quot;yes&quot;</span><br></pre></td></tr></table></figure><p>Map 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(function(value, key, map) &#123;</span><br><span class="line">  console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class="line">&#125;);</span><br><span class="line">forEach方法还可以接受第二个参数，用来绑定this。</span><br><span class="line"></span><br><span class="line">const reporter = &#123;</span><br><span class="line">  report: function(key, value) &#123;</span><br><span class="line">    console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map.forEach(function(value, key, map) &#123;</span><br><span class="line">  this.report(key, value);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure></p><p>上面代码中，forEach方法的回调函数的this，就指向reporter。</p><blockquote><p>与其他数据结构的互相转换</p></blockquote><p>（1）Map 转为数组<br>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（…）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const myMap = new Map()</span><br><span class="line">  .set(true, 7)</span><br><span class="line">  .set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</span><br><span class="line">[...myMap]</span><br><span class="line">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &apos;abc&apos; ] ] ]</span><br></pre></td></tr></table></figure></p><p>（2）数组 转为 Map<br>将数组传入 Map 构造函数，就可以转为 Map。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Map([</span><br><span class="line">  [true, 7],</span><br><span class="line">  [&#123;foo: 3&#125;, [&apos;abc&apos;]]</span><br><span class="line">])</span><br><span class="line">// Map &#123;</span><br><span class="line">//   true =&gt; 7,</span><br><span class="line">//   Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure></p><p>（3）Map 转为对象<br>如果所有 Map 的键都是字符串，它可以转为对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function strMapToObj(strMap) &#123;</span><br><span class="line">  let obj = Object.create(null);</span><br><span class="line">  for (let [k,v] of strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myMap = new Map()</span><br><span class="line">  .set(&apos;yes&apos;, true)</span><br><span class="line">  .set(&apos;no&apos;, false);</span><br><span class="line">strMapToObj(myMap)</span><br><span class="line">// &#123; yes: true, no: false &#125;</span><br></pre></td></tr></table></figure></p><p>（4）对象转为 Map<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function objToStrMap(obj) &#123;</span><br><span class="line">  let strMap = new Map();</span><br><span class="line">  for (let k of Object.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  return strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToStrMap(&#123;yes: true, no: false&#125;)</span><br><span class="line">// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;</span><br></pre></td></tr></table></figure></p><p>（5）Map 转为 JSON<br>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function strMapToJson(strMap) &#123;</span><br><span class="line">  return JSON.stringify(strMapToObj(strMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);</span><br><span class="line">strMapToJson(myMap)</span><br><span class="line">// &apos;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&apos;</span><br></pre></td></tr></table></figure></p><p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function mapToArrayJson(map) &#123;</span><br><span class="line">  return JSON.stringify([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</span><br><span class="line">mapToArrayJson(myMap)</span><br><span class="line">// &apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;</span><br></pre></td></tr></table></figure></p><p>（6）JSON 转为 Map<br>JSON 转为 Map，正常情况下，所有键名都是字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function jsonToStrMap(jsonStr) &#123;</span><br><span class="line">  return objToStrMap(JSON.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToStrMap(&apos;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&apos;)</span><br><span class="line">// Map &#123;&apos;yes&apos; =&gt; true, &apos;no&apos; =&gt; false&#125;</span><br></pre></td></tr></table></figure></p><p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是数组转为 JSON 的逆操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function jsonToMap(jsonStr) &#123;</span><br><span class="line">  return new Map(JSON.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToMap(&apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;)</span><br><span class="line">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;set&quot;&gt;&lt;a href=&quot;#set&quot; class=&quot;headerlink&quot; title=&quot;set&quot;&gt;&lt;/a&gt;set&lt;/h3&gt;&lt;p&gt;ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。开发中用于去除重复数据&lt;br&gt;Set 本身是一个构造函数，用来生成 Set 数据结构。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const s = new Set();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[2, 3, 5, 4, 5, 2, 2].forEach(x =&amp;gt; s.add(x));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for (let i of s) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 2 3 5 4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://www.leepeng..top/tags/js/"/>
    
      <category term="es6" scheme="http://www.leepeng..top/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>HTML-&amp;#65279导致页面顶部空白一行</title>
    <link href="http://www.leepeng..top/2017/08/05/2017-08-05-html/"/>
    <id>http://www.leepeng..top/2017/08/05/2017-08-05-html/</id>
    <published>2017-08-04T16:00:00.000Z</published>
    <updated>2017-12-21T04:37:25.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML-amp-65279导致页面顶部空白一行"><a href="#HTML-amp-65279导致页面顶部空白一行" class="headerlink" title="HTML-&amp;#65279导致页面顶部空白一行"></a>HTML-&amp;#65279导致页面顶部空白一行</h2><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1493726791787&amp;di=f558d6e07653574fbd96c1c09fc2ef1e&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.kuqin.com%2Fupimg%2Fallimg%2F110917%2F2314255128-0.jpg" alt="Alt text"></p><p>静态html页面，在浏览器中测试的时候，发现其中一个html页面的顶部多出了些许空白，而另一个页面显示正常。在浏览器中进行了审查对比，发现有空白的那个页面的head标签里面的元素全部跑到了body里面，而且body中还多出了一个，当把这个东西删除之后就正常了。然后又在编辑器中，对比了一下这两个页面的源码，发现head部分完全一样，body中的代码也没有什么异常。最后通过查阅相关资料，才发现原来是编码的问题。</p><br><p>页面的编码如果是UTF-8 + BOM，会在body开头处加入一个可见的控制符，导致页面头部会出现一个空白。这种编码方式一般会在windows操作系统中出现，比如记事本编辑器，在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。但对于html来说，BOM是个大麻烦。因为浏览器在解析html页面时，并不会忽略BOM，所以在解析html文件时，会把BOM作为该文件开头正文的一部分，这串字符也将会被直接执行（在页面中并不显示）出来。由此造成即使页面的 top或者padding 设置为0，也无法让整个网页紧贴浏览器顶部，因为在html一开头有这3个隐藏字符！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTML-amp-65279导致页面顶部空白一行&quot;&gt;&lt;a href=&quot;#HTML-amp-65279导致页面顶部空白一行&quot; class=&quot;headerlink&quot; title=&quot;HTML-&amp;amp;#65279导致页面顶部空白一行&quot;&gt;&lt;/a&gt;HTML-&amp;amp;#6
      
    
    </summary>
    
    
      <category term="html" scheme="http://www.leepeng..top/tags/html/"/>
    
      <category term="小问题" scheme="http://www.leepeng..top/tags/%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ES6-let,const</title>
    <link href="http://www.leepeng..top/2017/05/04/es6-lensson1/"/>
    <id>http://www.leepeng..top/2017/05/04/es6-lensson1/</id>
    <published>2017-05-03T16:00:00.000Z</published>
    <updated>2018-01-21T10:13:46.619Z</updated>
    
    <content type="html"><![CDATA[<h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><p>1、let命令， 用来声明变量。 它的用法类似于var， 但是所声明的变量， 只在let命令所在的代码块内有效。<br>2、变量一定要在声明后使用， 否则报错。<br>3、使用let命令声明变量之前， 该变量都是不可用的。<br>4、变量x使用let命令声明， 所以在声明之前， 都属于x的“死区”， 只要用到该变量就会报错。 因此， typeof运行时就会抛出一个ReferenceError。<br>5、let不允许在相同作用域内， 重复声明同一个变量。<br>eg:<br>{<br>    let a = 10;<br>    var b = 1;<br>}<br>console.log(a) // ReferenceError: a is not defined.<br>console.log(b) // 1<br>for循环的计数器，很适合使用let<br>eg:<br>for(let i =0;i&lt; arr.length;i++ ){}<br>console.log(i) // ReferenceError: a is not defined.<br><a id="more"></a></p><h3 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h3><p>1、const声明一个只读的常量。 一旦声明， 常量的值就不能改变。（ eg 1 ）<br>2、const声明的变量不得改变值， 这意味着， const一旦声明变量， 就必须立即初始化， 不能留到以后赋值。<br>3、const的作用域与let命令相同： 只在声明所在的块级作用域内有效。<br>4、const命令声明的常量也是不提升， 同样存在暂时性死区， 只能在声明的位置后面使用。<br>eg 1:<br>const PI = 3.1415;<br>PI // 3.1415<br>PI = 3;<br>// TypeError: Assignment to constant variable.<br>对于复合类型的变量， 变量名不指向数据， 而是指向数据所在的地址。const命令只是保证变量名指向的地址不变， 并不保证该地址的数据不变， 所以将一个对象声明为常量必须非常小心。<br>const foo = {};<br>foo.prop = 123;<br>foo.prop<br>// 123<br>foo = {}; // TypeError: “foo” is read-only<br>上面代码中， 常量foo储存的是一个地址， 这个地址指向一个对象。 不可变的只是这个地址， 即不能把foo指向另一个地址， 但对象本身是可变的， 所以依然可以为其添加新属性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;let命令&quot;&gt;&lt;a href=&quot;#let命令&quot; class=&quot;headerlink&quot; title=&quot;let命令&quot;&gt;&lt;/a&gt;let命令&lt;/h3&gt;&lt;p&gt;1、let命令， 用来声明变量。 它的用法类似于var， 但是所声明的变量， 只在let命令所在的代码块内有效。&lt;br&gt;2、变量一定要在声明后使用， 否则报错。&lt;br&gt;3、使用let命令声明变量之前， 该变量都是不可用的。&lt;br&gt;4、变量x使用let命令声明， 所以在声明之前， 都属于x的“死区”， 只要用到该变量就会报错。 因此， typeof运行时就会抛出一个ReferenceError。&lt;br&gt;5、let不允许在相同作用域内， 重复声明同一个变量。&lt;br&gt;eg:&lt;br&gt;{&lt;br&gt;    let a = 10;&lt;br&gt;    var b = 1;&lt;br&gt;}&lt;br&gt;console.log(a) // ReferenceError: a is not defined.&lt;br&gt;console.log(b) // 1&lt;br&gt;for循环的计数器，很适合使用let&lt;br&gt;eg:&lt;br&gt;for(let i =0;i&amp;lt; arr.length;i++ ){}&lt;br&gt;console.log(i) // ReferenceError: a is not defined.&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://www.leepeng..top/tags/js/"/>
    
      <category term="es6" scheme="http://www.leepeng..top/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>屏蔽双击选中文字的方法!</title>
    <link href="http://www.leepeng..top/2017/05/02/pingbishuangjixuanzhongzi/"/>
    <id>http://www.leepeng..top/2017/05/02/pingbishuangjixuanzhongzi/</id>
    <published>2017-05-01T16:00:00.000Z</published>
    <updated>2018-01-21T09:44:30.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="屏蔽双击选中文字的方法"><a href="#屏蔽双击选中文字的方法" class="headerlink" title="屏蔽双击选中文字的方法!"></a>屏蔽双击选中文字的方法!</h3><p><img src="/images/pingbi.jpg" class="full-image"></p><p>FF用样式 ：-moz-user-select:none;</p><p>FF以外的浏览器用：onselectstart=”return false”（直接加在需要作用的标签）</p><p>eg:  &lt;div class=”test” onselectstart=”return false” style=”-moz-user-select:none;” &gt;你选不到我。。。（屏蔽双击选中文字的区域）&lt;/div&gt;</p><p>如果你在标签里加了onselectstart=”return false” 那标签内的文字都没法选中了。。</p><h3 id="css禁止双击页面选中文本"><a href="#css禁止双击页面选中文本" class="headerlink" title="css禁止双击页面选中文本"></a>css禁止双击页面选中文本</h3><a id="more"></a><p>user-select：none | text | all | element<br>默认值：text<br>适用于：除替换元素外的所有元素<br>继承性：无<br>动画性：否<br>计算值：指定值<br>取值：<br>none：文本不能被选择<br>text：可以选择文本<br>all：当所有内容作为一个整体时可以被选择。如果双击或者在上下文上点击子元素，那么被选择的部分将是以该子元素向上回溯的最高祖先元素。<br>element：可以选择文本，但选择范围受元素边界的约束</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;屏蔽双击选中文字的方法&quot;&gt;&lt;a href=&quot;#屏蔽双击选中文字的方法&quot; class=&quot;headerlink&quot; title=&quot;屏蔽双击选中文字的方法!&quot;&gt;&lt;/a&gt;屏蔽双击选中文字的方法!&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/pingbi.jpg&quot; class=&quot;full-image&quot;&gt;&lt;/p&gt;
&lt;p&gt;FF用样式 ：-moz-user-select:none;&lt;/p&gt;
&lt;p&gt;FF以外的浏览器用：onselectstart=”return false”（直接加在需要作用的标签）&lt;/p&gt;
&lt;p&gt;eg:  &amp;lt;div class=”test” onselectstart=”return false” style=”-moz-user-select:none;” &amp;gt;你选不到我。。。（屏蔽双击选中文字的区域）&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;如果你在标签里加了onselectstart=”return false” 那标签内的文字都没法选中了。。&lt;/p&gt;
&lt;h3 id=&quot;css禁止双击页面选中文本&quot;&gt;&lt;a href=&quot;#css禁止双击页面选中文本&quot; class=&quot;headerlink&quot; title=&quot;css禁止双击页面选中文本&quot;&gt;&lt;/a&gt;css禁止双击页面选中文本&lt;/h3&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://www.leepeng..top/tags/js/"/>
    
      <category term="css" scheme="http://www.leepeng..top/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>bootstrap在模态框里加载iframe页面（iframe里的关闭按钮）的时候如何关闭模态框</title>
    <link href="http://www.leepeng..top/2017/05/02/bootstrap-addiframe-close-modal/"/>
    <id>http://www.leepeng..top/2017/05/02/bootstrap-addiframe-close-modal/</id>
    <published>2017-05-01T16:00:00.000Z</published>
    <updated>2018-01-21T10:08:36.673Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/bootstrap.jpg" class="full-image"></p><p>bootstrap在模态框里加载iframe页面（iframe里的关闭按钮）的时候如何关闭模态框<br>window.parent.$(‘#myModal’).modal(‘hide’);<br><a id="more"></a><br>eg:<br>window.self<br>功能：是对当前窗口自身的引用。它和window属性是等价的。<br>语法：window.self<br>注：window、self、window.self是等价的。</p><p>window.top<br>功能：返回顶层窗口，即浏览器窗口。<br>语法：window.top<br>注：如果窗口本身就是顶层窗口，top属性返回的是对自身的引用。</p><p>window.parent<br>功能：返回父窗口。<br>语法：window.parent<br>注：如果窗口本身是顶层窗口，parent属性返回的是对自身的引用。<br>在框架网页中，一般父窗口就是顶层窗口，但如果框架中还有框架，父窗口和顶层窗口就不一定相同了。</p><p>判断当前窗口是否在一个框架中：</p><p>&lt; script type=”text/JavaScript” &gt;<br>var b = window.top!=window.self;<br>document.write( “当前窗口是否在一个框架中：”+b );<br>&lt; /script &gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/bootstrap.jpg&quot; class=&quot;full-image&quot;&gt;&lt;/p&gt;
&lt;p&gt;bootstrap在模态框里加载iframe页面（iframe里的关闭按钮）的时候如何关闭模态框&lt;br&gt;window.parent.$(‘#myModal’).modal(‘hide’);&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://www.leepeng..top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>老是忘记的小问题!</title>
    <link href="http://www.leepeng..top/2017/05/02/wangjidexiaowenti/"/>
    <id>http://www.leepeng..top/2017/05/02/wangjidexiaowenti/</id>
    <published>2017-05-01T16:00:00.000Z</published>
    <updated>2018-01-21T10:00:37.445Z</updated>
    
    <content type="html"><![CDATA[<p>1、火狐FF里INPUT标签刷新页面后 仍然保存之前输入的内容。</p><p>直接在input 标签里 增加 autocomplete=”off”。火狐默认为 on。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、火狐FF里INPUT标签刷新页面后 仍然保存之前输入的内容。&lt;/p&gt;
&lt;p&gt;直接在input 标签里 增加 autocomplete=”off”。火狐默认为 on。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="html" scheme="http://www.leepeng..top/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.leepeng..top/2017/05/01/hello-world/"/>
    <id>http://www.leepeng..top/2017/05/01/hello-world/</id>
    <published>2017-04-30T16:00:00.000Z</published>
    <updated>2018-01-21T09:43:08.637Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to LeePeng’s <a href="www.leepeng.top/">blog</a>! </p><p><img src="/images/about-bg.jpg" class="full-image"></p><p>我是李鹏，web前端 &amp; 设计师。<br>音乐重度依赖患者，设计师强迫症患者，<br>书买得比看得多患者，毒舌患者，<br>间歇性感伤患者，<br>习惯性熬夜患者。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to LeePeng’s &lt;a href=&quot;www.leepeng.top/&quot;&gt;blog&lt;/a&gt;! &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/about-bg.jpg&quot; class=&quot;full-image&quot;&gt;&lt;/p&gt;
&lt;p&gt;我是李鹏，web前端 &amp;
      
    
    </summary>
    
    
  </entry>
  
</feed>
