<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[倒计时效果]]></title>
    <url>%2F2017%2F08%2F06%2Fcountdown%2F</url>
    <content type="text"><![CDATA[当前时间 倒计时1 距离设置时间还有天倒计时2 距离设置时间2019/1/1,00:00:00还有 window.onload= function () { showtime(); dao1(); dao2(); } function formatTime(i){ if(i 0 ){ document.getElementById('dao1').innerHTML = daytime; } } //倒计时1 //倒计时2 function dao2(){ let nowtime = new Date(); let endtime = new Date("2019/1/1,00:00:00"); let time = parseInt((endtime.getTime() - nowtime.getTime())/1000);//秒 let d = parseInt(time/(24*60*60)); let h = parseInt(time/(60*60)%24); let m = parseInt(time/60%60); let s = parseInt(time%60); m = formatTime(m); s = formatTime(s); document.getElementById('dao2').innerHTML = d+'天'+h+'时'+m+'分'+s+'秒'; setTimeout(dao2,500) } 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;p&gt;当前时间&lt;/p&gt;&lt;div id="time"&gt;&lt;/div&gt;&lt;p&gt;倒计时1&lt;/p&gt;&lt;div class="dao1"&gt;距离设置时间还有&lt;span id="dao1"&gt;&lt;/span&gt;天&lt;/div&gt;&lt;p&gt;倒计时2&lt;/p&gt;&lt;div class="dao2"&gt;距离设置时间2019/1/1,00:00:00还有&lt;span id="dao2"&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; window.onload= function () &#123; showtime(); dao1(); dao2(); &#125; function formatTime(i)&#123; if(i&lt;10)&#123; i='0'+i; &#125; return i; &#125; //当前时间 function showtime()&#123; let myDate = new Date(); let year = myDate.getFullYear();//年 let month = myDate.getMonth();//月 let date = myDate.getDate();//日 let day = myDate.getDay();//星期 let h = myDate.getHours();//时 let m = myDate.getMinutes();//分 let s = myDate.getSeconds();//秒 m = formatTime(m); s = formatTime(s); let time=document.getElementById("time"); let weekday = ['星期日','星期一','星期二','星期三','星期四','星期五','星期六',''] time.innerHTML=year+'年'+month+'月'+date+'日 '+weekday[day]+' '+h+':'+m+':'+s; setTimeout(showtime,500); &#125; //当前时间 //倒计时1 function dao1()&#123; let curtime = new Date(); let endtime = new Date("2019,1,1"); let time = endtime.getTime() - curtime.getTime();//getTime()毫秒 //1000 * 60 * 60 * 24一天的秒数 //利用Math.ceil()对象方法，对得出的时间差进行向上取整。 //parseInt()取整。 daytime = parseInt(time/(1000 * 60 * 60 * 24)) if(daytime &gt; 0 )&#123; document.getElementById('dao1').innerHTML = daytime; &#125; &#125; //倒计时1 //倒计时2 function dao2()&#123; let nowtime = new Date(); let endtime = new Date("2019/1/1,00:00:00"); let time = parseInt((endtime.getTime() - nowtime.getTime())/1000);//秒 let d = parseInt(time/(24*60*60)); let h = parseInt(time/(60*60)%24); let m = parseInt(time/60%60); let s = parseInt(time%60); m = formatTime(m); s = formatTime(s); document.getElementById('dao2').innerHTML = d+'天'+h+'时'+m+'分'+s+'秒'; setTimeout(dao2,500) &#125; //倒计时2&lt;/script&gt;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML-&#65279导致页面顶部空白一行]]></title>
    <url>%2F2017%2F08%2F05%2Fhtml-kongbai%2F</url>
    <content type="text"><![CDATA[HTML-&amp;#65279导致页面顶部空白一行 静态html页面，在浏览器中测试的时候，发现其中一个html页面的顶部多出了些许空白，而另一个页面显示正常。在浏览器中进行了审查对比，发现有空白的那个页面的head标签里面的元素全部跑到了body里面，而且body中还多出了一个，当把这个东西删除之后就正常了。然后又在编辑器中，对比了一下这两个页面的源码，发现head部分完全一样，body中的代码也没有什么异常。最后通过查阅相关资料，才发现原来是编码的问题。页面的编码如果是UTF-8 + BOM，会在body开头处加入一个可见的控制符，导致页面头部会出现一个空白。这种编码方式一般会在windows操作系统中出现，比如记事本编辑器，在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。但对于html来说，BOM是个大麻烦。因为浏览器在解析html页面时，并不会忽略BOM，所以在解析html文件时，会把BOM作为该文件开头正文的一部分，这串字符也将会被直接执行（在页面中并不显示）出来。由此造成即使页面的 top或者padding 设置为0，也无法让整个网页紧贴浏览器顶部，因为在html一开头有这3个隐藏字符！]]></content>
      <tags>
        <tag>html</tag>
        <tag>小问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面布局]]></title>
    <url>%2F2017%2F05%2F06%2Fyemianbuju%2F</url>
    <content type="text"><![CDATA[页面布局的方法一、float：具有局限性，优缺点： 1.脱离文档流 2.兼容性好 3.要清除浮动二、绝对定位：position:absolute;优缺点： 1.脱离文档流 2.快捷，方便三、flexbox布局felxbox布局是css3里新出的一个，它就是为了解决上述两种方式的不足出现的，是比较完美的一个。目前移动端的布局也都是用flexbox。felxbox的缺点就是不能兼容IE8及以下浏览器。四、表格布局表格布局在历史上遭到很多人的摒弃，说表格布局麻烦，操作比较繁琐，其实这是一种误解，在很多场景中，表格布局还是很适用的，比如这个三栏布局，用表格布局就轻易写出来了。还有表格布局的兼容性很好，在flex布局不兼容的时候，可以尝试表格布局。表格布局也是有缺陷的，当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，而有时候这种效果不是我们想要的。五、网格布局网格布局也是新出的一种布局方式，兼容性是一个缺点。1234567891011121314151617181920212223242526272829&lt;style&gt;/*共用样式*/*&#123;margin:0;padding:0;&#125;section&#123;margin-bottom: 15px;&#125;.layout,.layout article div&#123;min-height:100px;&#125;.layout article .left,.layout article .right&#123;width: 300px;background: #333;&#125;.layout article .center&#123;background:#999;&#125;&lt;/style&gt;&lt;p&gt;float-浮动布局&lt;/p&gt;&lt;section class=&quot;layout float&quot;&gt; &lt;style&gt;.layout.float .left&#123;float: left;&#125;.layout.float .right&#123;float: right;&#125;.layout.float .center&#123; margin:0 300px 0 300px;&#125; &lt;/style&gt; &lt;article class=&quot;content&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h3&gt;两侧固定，中间自适应-float&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-float&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-float&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-float&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-float&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-float&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-float&lt;/h3&gt; &lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;p&gt;绝对定位布局&lt;/p&gt;&lt;section class=&quot;layout absolute&quot;&gt; &lt;style&gt; .layout.absolute .content&gt;div&#123;position: absolute;&#125; .layout.absolute .left&#123;left:0;&#125; .layout.absolute .center&#123;left:300px;right:300px;&#125; .layout.absolute .right&#123;right:0;&#125; &lt;/style&gt; &lt;article class=&quot;content&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h3&gt;两侧固定，中间自适应-absolite&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-absolite&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-absolite&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-absolite&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-absolite&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-absolite&lt;/h3&gt; &lt;/div&gt; &lt;/article&gt;&lt;/section&gt;&lt;p&gt;flexbox布局&lt;/p&gt;&lt;section class=&quot;layout flexbox&quot;&gt; &lt;style&gt; .flexbox .content&#123;display: flex;&#125; .flexbox .left&#123;&#125; .flexbox .center&#123;flex:1;&#125; .flexbox .right&#123;&#125; &lt;/style&gt; &lt;article class=&quot;content&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h3&gt;flexbox&lt;/h3&gt; &lt;h3&gt;flexbox&lt;/h3&gt; &lt;h3&gt;flexbox&lt;/h3&gt; &lt;h3&gt;flexbox&lt;/h3&gt; &lt;h3&gt;flexbox&lt;/h3&gt; &lt;h3&gt;flexbox&lt;/h3&gt; &lt;h3&gt;flexbox&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt;&lt;p&gt;table-cell布局&lt;/p&gt;&lt;section class=&quot;layout table&quot;&gt; &lt;style&gt; .layout.table .centent&#123;display:table;width:100%;&#125; .layout.table .centent&gt;div&#123;display: table-cell;&#125; &lt;/style&gt; &lt;article class=&quot;centent&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;p&gt;table&lt;/p&gt; &lt;p&gt;table&lt;/p&gt; &lt;p&gt;table&lt;/p&gt; &lt;p&gt;table&lt;/p&gt; &lt;p&gt;table&lt;/p&gt; &lt;p&gt;table&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt;&lt;p&gt;网格布局&lt;/p&gt;&lt;section class=&quot;layout grid&quot;&gt; &lt;style&gt; .layout.grid .centent&#123; display: grid; width:100%; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; &#125; &lt;/style&gt; &lt;article class=&quot;centent&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;p&gt;grid&lt;/p&gt; &lt;p&gt;grid&lt;/p&gt; &lt;p&gt;grid&lt;/p&gt; &lt;p&gt;grid&lt;/p&gt; &lt;p&gt;grid&lt;/p&gt; &lt;p&gt;grid&lt;/p&gt; &lt;p&gt;grid&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6-set-map]]></title>
    <url>%2F2017%2F05%2F05%2Fes6-set-map%2F</url>
    <content type="text"><![CDATA[setES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。开发中用于去除重复数据Set 本身是一个构造函数，用来生成 Set 数据结构。 123456const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 Set 方法 1、新建new Set([‘…’])2、获取个数.size3、添加add、删除delete、是否包含has、清除clear4、keys和values都是相等的5、类似于数组没有重复的元素（唯一的） 12345678let s=new Set([1,2,3,3]);console.log(&quot;arr:&quot;,arr) // 返回1,2,3 去除重复数据s.add(4).add(4) // 注意4被加入了两次s.delete(2)console.log(&quot;s:&quot;,s.has(4)) // trueconsole.log(&quot;s:&quot;,s.keys())console.log(&quot;s:&quot;,s.values())s.clear() 下面是一个对比，看看在判断是否包括一个键上面，Object结构和Set结构的写法不同。 123456789101112131415// 对象的写法const properties = &#123; &apos;width&apos;: 1, &apos;height&apos;: 1&#125;;if (properties[someName]) &#123; // do something&#125;// Set的写法const properties = new Set();properties.add(&apos;width&apos;);properties.add(&apos;height&apos;);if (properties.has(someName)) &#123; // do something&#125; Array.from方法可以将 Set 结构转为数组。 12const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items); 这就提供了去除数组重复成员的另一种方法。 12345function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] 遍历操作 Set 结构的实例有四个遍历方法，可以用于遍历成员。 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 12345678910111213141516171819202122let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;] 直接用for…of循环遍历 Set。 1234567let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);for (let x of set) &#123; console.log(x);&#125;// red// green// blue forEach方法，用于对每个成员执行某种操作，没有返回值。 12345set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + &apos; : &apos; + value))// 1 : 1// 4 : 4// 9 : 9 mapES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。1、新建new Map([])2、 size:属性返回 Map 结构的成员总数 set(key, value):添加一个新建元素到映射。 get(key):返回映射中的指定元素。 has(key):如果映射包含指定元素，则返回 true。 delete(key):从映射中移除指定的元素。 clear:从映射中移除所有元素。 forEach:对映射中的每个元素执行指定操作。 toString:返回映射的字符串表示形式。 valueOf:返回指定对象的原始值。12345678910111213141516171819const map = new Map([ [&apos;name&apos;,&apos;leepeng&apos;], [&apos;age&apos;,24], [&apos;sex&apos;,&apos;男&apos;], [obj1,&apos;sfsfdsfe&apos;], [obj2,&apos;lihfksdnsiu&apos;], [[1,2,3],&apos;haha&apos;]])map.set(&apos;friends&apos;,[&apos;ffff&apos;,&apos;gggg&apos;])console.log(map.size)console.log(map)console.log(map.get(&apos;name&apos;))console.log(map.delete(&apos;name&apos;))console.log(map.has(&apos;age&apos;))//map.clear();console.log(map)map.forEach(function (value,index) &#123; console.log(index+&apos;:&apos;+value)&#125;) 遍历方法 Map 结构原生提供三个遍历器生成函数和一个遍历方法。keys()：返回键名的遍历器。values()：返回键值的遍历器。entries()：返回所有成员的遍历器。forEach()：遍历 Map 的所有成员。需要特别注意的是，Map 的遍历顺序就是插入顺序。 123456789101112131415161718192021222324252627282930313233343536const map = new Map([ [&apos;F&apos;, &apos;no&apos;], [&apos;T&apos;, &apos;yes&apos;],]);for (let key of map.keys()) &#123; console.log(key);&#125;// &quot;F&quot;// &quot;T&quot;for (let value of map.values()) &#123; console.log(value);&#125;// &quot;no&quot;// &quot;yes&quot;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot; Map 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。1234567891011121314map.forEach(function(value, key, map) &#123; console.log(&quot;Key: %s, Value: %s&quot;, key, value);&#125;);forEach方法还可以接受第二个参数，用来绑定this。const reporter = &#123; report: function(key, value) &#123; console.log(&quot;Key: %s, Value: %s&quot;, key, value); &#125;&#125;;map.forEach(function(value, key, map) &#123; this.report(key, value);&#125;, reporter); 上面代码中，forEach方法的回调函数的this，就指向reporter。 与其他数据结构的互相转换 （1）Map 转为数组前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（…）。12345const myMap = new Map() .set(true, 7) .set(&#123;foo: 3&#125;, [&apos;abc&apos;]);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &apos;abc&apos; ] ] ] （2）数组 转为 Map将数组传入 Map 构造函数，就可以转为 Map。12345678new Map([ [true, 7], [&#123;foo: 3&#125;, [&apos;abc&apos;]]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]// &#125; （3）Map 转为对象如果所有 Map 的键都是字符串，它可以转为对象。12345678910111213function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map() .set(&apos;yes&apos;, true) .set(&apos;no&apos;, false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; （4）对象转为 Map12345678910function objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125; （5）Map 转为 JSONMap 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。1234567function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);strMapToJson(myMap)// &apos;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&apos; 另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。1234567function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);mapToArrayJson(myMap)// &apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos; （6）JSON 转为 MapJSON 转为 Map，正常情况下，所有键名都是字符串。123456function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap(&apos;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&apos;)// Map &#123;&apos;yes&apos; =&gt; true, &apos;no&apos; =&gt; false&#125; 但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是数组转为 JSON 的逆操作。123456function jsonToMap(jsonStr) &#123; return new Map(JSON.parse(jsonStr));&#125;jsonToMap(&apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;)// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]&#125;]]></content>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-let,const]]></title>
    <url>%2F2017%2F05%2F04%2Fes6-lensson1%2F</url>
    <content type="text"><![CDATA[let命令1、let命令， 用来声明变量。 它的用法类似于var， 但是所声明的变量， 只在let命令所在的代码块内有效。2、变量一定要在声明后使用， 否则报错。3、使用let命令声明变量之前， 该变量都是不可用的。4、变量x使用let命令声明， 所以在声明之前， 都属于x的“死区”， 只要用到该变量就会报错。 因此， typeof运行时就会抛出一个ReferenceError。5、let不允许在相同作用域内， 重复声明同一个变量。123456&#123; let a = 10; var b = 1;&#125; console.log(a) // ReferenceError: a is not defined.console.log(b) // 1 for循环的计数器，很适合使用let12for(let i =0;i&lt; arr.length;i++ )&#123;&#125;console.log(i) // ReferenceError: a is not defined. const 命令1、const声明一个只读的常量。 一旦声明， 常量的值就不能改变。（ eg 1 ）2、const声明的变量不得改变值， 这意味着， const一旦声明变量， 就必须立即初始化， 不能留到以后赋值。3、const的作用域与let命令相同： 只在声明所在的块级作用域内有效。4、const命令声明的常量也是不提升， 同样存在暂时性死区， 只能在声明的位置后面使用。123const PI = 3.1415;PI // 3.1415PI = 3; // TypeError: Assignment to constant variable.对于复合类型的变量， 变量名不指向数据， 而是指向数据所在的地址。const命令只是保证变量名指向的地址不变， 并不保证该地址的数据不变， 所以将一个对象声明为常量必须非常小心。12345const foo = &#123;&#125;;foo.prop = 123;foo.prop// 123foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only 上面代码中， 常量foo储存的是一个地址， 这个地址指向一个对象。 不可变的只是这个地址， 即不能把foo指向另一个地址， 但对象本身是可变的， 所以依然可以为其添加新属性。]]></content>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap在模态框里加载iframe页面（iframe里的关闭按钮）的时候如何关闭模态框]]></title>
    <url>%2F2017%2F05%2F02%2Fbootstrap-addiframe-close-modal%2F</url>
    <content type="text"><![CDATA[bootstrap在模态框里加载iframe页面（iframe里的关闭按钮）的时候如何关闭模态框window.parent.$(‘#myModal’).modal(‘hide’);eg:window.self功能：是对当前窗口自身的引用。它和window属性是等价的。语法：window.self注：window、self、window.self是等价的。 window.top功能：返回顶层窗口，即浏览器窗口。语法：window.top注：如果窗口本身就是顶层窗口，top属性返回的是对自身的引用。 window.parent功能：返回父窗口。语法：window.parent注：如果窗口本身是顶层窗口，parent属性返回的是对自身的引用。在框架网页中，一般父窗口就是顶层窗口，但如果框架中还有框架，父窗口和顶层窗口就不一定相同了。 判断当前窗口是否在一个框架中： &lt; script type=”text/JavaScript” &gt;var b = window.top!=window.self;document.write( “当前窗口是否在一个框架中：”+b );&lt; /script &gt;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[屏蔽双击选中文字的方法!]]></title>
    <url>%2F2017%2F05%2F02%2Fpingbishuangjixuanzhongzi%2F</url>
    <content type="text"><![CDATA[屏蔽双击选中文字的方法! FF用样式 ：-moz-user-select:none; FF以外的浏览器用：onselectstart=”return false”（直接加在需要作用的标签） eg: &lt;div class=”test” onselectstart=”return false” style=”-moz-user-select:none;” &gt;你选不到我。。。（屏蔽双击选中文字的区域）&lt;/div&gt; 如果你在标签里加了onselectstart=”return false” 那标签内的文字都没法选中了。。 css禁止双击页面选中文本 user-select：none | text | all | element默认值：text适用于：除替换元素外的所有元素继承性：无动画性：否计算值：指定值取值：none：文本不能被选择text：可以选择文本all：当所有内容作为一个整体时可以被选择。如果双击或者在上下文上点击子元素，那么被选择的部分将是以该子元素向上回溯的最高祖先元素。element：可以选择文本，但选择范围受元素边界的约束]]></content>
      <tags>
        <tag>js</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老是忘记的小问题!]]></title>
    <url>%2F2017%2F05%2F02%2Fwangjidexiaowenti%2F</url>
    <content type="text"><![CDATA[1、火狐FF里INPUT标签刷新页面后 仍然保存之前输入的内容。 直接在input 标签里 增加 autocomplete=”off”。火狐默认为 on。]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to LeePeng’s blog! 我是李鹏，web前端 &amp; 设计师。音乐重度依赖患者，设计师强迫症患者，书买得比看得多患者，毒舌患者，间歇性感伤患者，习惯性熬夜患者。]]></content>
  </entry>
</search>
