<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分页组件pagination]]></title>
    <url>%2F2018%2F08%2F17%2Fpage-pagination%2F</url>
    <content type="text"><![CDATA[分页组件需求如下 1、最多连续显示5页，居中高亮显示current页（如demo1所示)2、total为0时，隐藏整个元素（如demo2所示）3、如果total&lt;=5，则显示全部页数，隐藏“首页”和“末页”元素（如demo3所示）4、当current居中不足5页，向后(前)补足5页，隐藏“首页”(“末页”)元素(如demo4和demo5所示)5、total、current均为正整数，1 &lt;= current（当前） &lt;= total（总页数） #jsPagination ul{display: flow-root;}#jsPagination ul li{display: inline-block; border:1px solid #999; padding: 3px 10px;}#jsPagination ul li.cur{background: #999;} const perpages=5;//按钮个数 const step = (perpages-1)/2; let jsPaginationbox = document.querySelector('#jsPagination') function jsPagination(total,current){ jsPaginationbox.innerHTML=''; const _step = { start:current-step, end:current+step } if(_step.starttotal){ _step.start = _step.start - (_step.end - total); _step.end = total; //console.log(_step.end,_step.start) } if (_step.start < 1) _step.start = 1 //console.log(_step.end,_step.start) let htmlLi='' let Ul = document.createElement('ul'); if(current !==1 ){ htmlLi += '上一页' } for (let i = _step.start; i]]></content>
      <tags>
        <tag>-js -分页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取url参数]]></title>
    <url>%2F2018%2F03%2F02%2Fget-url-parameter%2F</url>
    <content type="text"><![CDATA[获取url参数 指定参数名称，返回该参数的值 或者 空字符串 不指定参数名称，返回全部的参数对象 或者 {} 如果存在多个同名参数，则返回数组window.location.href 取当前页面url 1234567891011121314151617181920212223242526272829303132333435// 获取 url 中的参数 let Urlstr = &apos;http://www.nowcoder.com?key=1&amp;key=2&amp;key=3&amp;test=4#hehe&apos;; function getUrlParam(sUrl, sKey) &#123; console.log(sKey) let queryString = sUrl.split(&apos;#&apos;)[0].split(&apos;?&apos;)[1]; console.log(queryString) // queryString==undefined ===&gt;url中没有？||# // queryString==&apos;&apos; ===&gt;url中有？||# 但没参数 if(queryString==undefined || queryString==&apos;&apos;)&#123; if(sKey==undefined)&#123; // 是否有传入key return &#123;&#125; &#125;else&#123; return &apos;&apos;; &#125; &#125; let query = queryString.split(&apos;&amp;&apos;); let newObj=&#123;&#125;; for(let i=0;i&lt;query.length;i++)&#123; let keyValue = query[i].split(&apos;=&apos;); let key = keyValue[0] let value = keyValue[1] if (!(key in newObj)) &#123; newObj[key] = []; &#125; newObj[key].push(value); &#125; console.log(newObj) if(sKey)&#123; // console.log(newObj[sKey]) return newObj[sKey] ? newObj[sKey] : &apos;&apos; &#125;else&#123; return newObj &#125; &#125; console.log(getUrlParam(Urlstr,&apos;key&apos;))]]></content>
      <tags>
        <tag>-js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX]]></title>
    <url>%2F2017%2F11%2F21%2Fajax%2F</url>
    <content type="text"><![CDATA[前端通信1、同源策略及限制 源：协议(http://,https://)，域名 (www.leepeng.top)，端口(:8080)不是一个源的文档没有权利去操作另一个源的文档，包括Cookie/LocalStorage/IndexDB无法读取DOM无法获取，Ajax请求不能发送同源策略限制不同的源的文档之间进行交互 2、前后端通信 Ajax:同源限制WebSocket:不受限制CORS:支持同源，也支持非同源(新的通信协议标准) 3、创建Ajax 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。XMLHttpRequest对象的工作流程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function ajax(opt)&#123; var xhr = XMLHttpRequest ? new XMLHttpRequest() : window.ActiveObject(&apos;Microsoft.XMLHTTP&apos;); //兼容6 var data = opt.data || null; var url = opt.url || &apos;&apos;; var type = opt.type.toUpperCase() || &apos;GET&apos;; // .toUpperCase()把字符串转换为大写 var success = opt.sucess || function() &#123;&#125; var dataArr = []; for(k in data)&#123; dataArr.push(k + &apos;=&apos; + data[k]); &#125; if(type === &apos;GET&apos;)&#123; url = url +&apos;?&apos; + dataArr.join(&apos;&amp;&apos;); xhr.open(type,url.reolace(/\?$/g,&apos;&apos;),true); //如果以？结尾，则将问号去掉 xhr.send(); &#125; if(type === &apos;POST&apos;)&#123; xhr.open(type,url,true); xhr.setRequestHeader(&apos;content-type&apos;,&apos;application/x-www-form-urlencoded&apos;); xhr.send(dataArr.join(&apos;&amp;&apos;)); &#125; xhr.onreadystatechange = function() &#123; var res = null; if(xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr.status === 304) &#123; // 304得用本地缓存 res = xhr.responseText if (typeof res ==== &apos;string&apos;) &#123; res = JSON.parse(res); &#125; success(res); &#125; &#125; &#125;&#125;// 调用ajax(&#123; type: &apos;GET&apos;, &quot;url&quot;:&quot;http://www.leepeng.top&quot;, &quot;data&quot;:&#123; &quot;id&quot;:123456, &quot;name&quot;:&quot;leepeng&quot; &#125;, success: function(res)&#123; console.log(res) &#125;&#125;) 4、跨域通信 JSONPHash (hash改变，页面不刷新，？后是search,改变时会刷新页面)postMessage (新技术，html5的标准)WebSocketCORS (可以理解为支持跨域通信的变种Ajax。当你在浏览器中发送一个ajax跨域请求时，浏览器会在http头中加入一个origin。如果只是一个普通的ajax，则会被浏览器拦截) 4.1 JSONP 只用于GET12345678910// 在www.aaa.com页面中&lt;script&gt;function jsonp(json) &#123; alert(json[&apos;name&apos;])&#125;&lt;/script&gt;&lt;script src=&quot;http://localhost/ajax/jsonp.js&quot;&gt;&lt;/script&gt;// 在wwww.bbb.com 页面中jsonp(&#123;&apos;name&apos;:&apos;leepeng&apos;,&apos;age&apos;:28&#125;) 4.2 jsonp 封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* Object.prototype.toString.call(source) source为对象时返回[object Object] ------为数组时返回[object Array] ------为数字时返回[object Number] ------为字符串时返回[object String]*/function isFunction(fn) &#123; //判断是不是函数Object.prototype.toString.call() return &apos;[object Function]&apos; === Object.prototype.toString.call(fn);&#125;;function createScript(url) &#123; let script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;type&apos;,&apos;text/javascript&apos;); script.setAttribute(&apos;charset&apos;, &apos;utf-8&apos;); script.setAttribute(&apos;src&apos;, url); console.log(script) return script;&#125;// [function 在页面中注入js脚本]function jsonp(url, onsuccess, onerror) &#123; var callbackName; window[callback] = function() &#123; if(onsuccess &amp;&amp; isFunction(onsuccess)) &#123; onsuccess(arguments[0]) &#125; &#125; var script = createScript(url + &apos;?callback=&apos; + callbackName); script.onload = script.onreadystatechange = function () &#123; if (!script.readyState || /loaded|complete/.test(script.readyState)) &#123; script.onload = script.onreadystatechange = null; // 移除该script的 DOM 对象 if (script.parentNode) &#123; script.parentNode.removeChild(script); &#125; // 删除函数或变量 window[callbackName] = null; &#125; &#125;; script.onerror = function () &#123; if (onerror &amp;&amp; util.isFunction(onerror)) &#123; onerror(); &#125; &#125;; document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);&#125;// 调用var url = &apos;http://localhost/ajax/jsonp.js&apos;jsonp(url, function onsuccess(res)&#123; console.log(res)&#125;, function onerror(err)&#123; console.log(err)&#125;)// jquery jsonp$.getJSON(&quot;http://www.aaa.com/jsonp.php?jsoncallback=callback&quot;, function(res) &#123; var data = res&#125;); 4.3 利用hash 场景是当前页面 A 通过iframe或frame嵌入了跨域的页面 B1234567// 在A中伪代码如下：var B = document.getElementsByTagName(&apos;iframe&apos;);B.src = B.src + &apos;#&apos; + &apos;data&apos;;// 在B中的伪代码如下window.onhashchange = function () &#123; var data = window.location.hash;&#125;; 4.4 postMessage 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息1234567Bwindow.postMessage(&apos;data&apos;, &apos;http://B.com&apos;);// 在窗口B中监听Awindow.addEventListener(&apos;message&apos;, function (event) &#123; console.log(event.origin); console.log(event.source); console.log(event.data);&#125;, false); 4.5 Websocket [参考资料] http://www.ruanyifeng.com/blog/2017/05/websocket.html123456789101112131415var ws = new WebSocket(&apos;wss://echo.websocket.org&apos;);ws.onopen = function (evt) &#123; console.log(&apos;Connection open ...&apos;); ws.send(&apos;Hello WebSockets!&apos;);&#125;;ws.onmessage = function (evt) &#123; console.log(&apos;Received Message: &apos;, evt.data); ws.close();&#125;;ws.onclose = function (evt) &#123; console.log(&apos;Connection closed.&apos;);&#125;; 4.6 CORS [参考资料] http://www.ruanyifeng.com/blog/2016/04/cors.html12345678// url（必选），options（可选）fetch(&apos;/some/url/&apos;, &#123; method: &apos;get&apos;,&#125;).then(function (response) &#123;&#125;).catch(function (err) &#123; //出错了，等价于 then 的第二个参数，但这样更好用更直观&#125;); 4.6.1 CORS-GET请求的参数传递12345678910// 通过fetch获取百度的错误提示页面fetch(&apos;https://www.baidu.com/search/error.html?a=1&amp;b=2&apos;, &#123; // 在URL中写上传递的参数 method: &apos;GET&apos; &#125;) .then((res)=&gt;&#123; return res.text() &#125;) .then((res)=&gt;&#123; console.log(res) &#125;) 4.6.2 POST请求参数的传递 众所周知，POST请求的参数，一定不能放在URL中，这样做的目的是防止信息泄露。在POST提交的过程中，一般是表单提交，可是，经过查询，发现默认的提交方式是：Content-Type:text/plain;charset=UTF-8，所以需要指定头信息12345678910111213141516// 通过fetch获取百度的错误提示页面fetch(&apos;https://www.baidu.com/search/error.html&apos;, &#123; method: &apos;POST&apos;, headers: new Headers(&#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; // 指定提交方式为表单提交 // &apos;Accept&apos;: &apos;application/json&apos; // 通过头指定，获取的数据类型是JSON &#125;), body: new URLSearchParams([[&quot;foo&quot;, 1],[&quot;bar&quot;, 2]]).toString() // 这里是请求对象 &#125;) .then((res)=&gt;&#123; return res.text() // return res.json() // 返回一个Promise，可以解析成JSON 与headers中指定json数据类型对应 &#125;) .then((res)=&gt;&#123; console.log(res) &#125;) 4.6.3 fetch封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 将对象转成 a=1&amp;b=2的形式 * @param obj 对象 */function obj2String(obj, arr = [], idx = 0) &#123; for (let item in obj) &#123; arr[idx++] = [item, obj[item]] &#125; return new URLSearchParams(arr).toString()&#125;/** * 真正的请求 * @param url 请求地址 * @param options 请求参数 * @param method 请求方式 */function commonFetcdh(url, options, method = &apos;GET&apos;) &#123; const searchStr = obj2String(options) let initObj = &#123;&#125; if (method === &apos;GET&apos;) &#123; // 如果是GET请求，拼接url url += &apos;?&apos; + searchStr initObj = &#123; method: method, credentials: &apos;include&apos; &#125; &#125; else &#123; initObj = &#123; method: method, credentials: &apos;include&apos;, headers: new Headers(&#123; &apos;Accept&apos;: &apos;application/json&apos;, &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125;), body: searchStr &#125; &#125; fetch(url, initObj).then((res) =&gt; &#123; return res.json() &#125;).then((res) =&gt; &#123; return res &#125;)&#125;/** * GET请求 * @param url 请求地址 * @param options 请求参数 */function GET(url, options) &#123; return commonFetcdh(url, options, &apos;GET&apos;)&#125;/** * POST请求 * @param url 请求地址 * @param options 请求参数 */function POST(url, options) &#123; return commonFetcdh(url, options, &apos;POST&apos;)&#125;// 调用GET(&apos;https://www.baidu.com/search/error.html&apos;, &#123;a:1,b:2&#125;)POST(&apos;https://www.baidu.com/search/error.html&apos;, &#123;a:1,b:2&#125;)]]></content>
      <tags>
        <tag>-js -ajax -异步请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE-项目手动搭建]]></title>
    <url>%2F2017%2F10%2F05%2Fvue-xiangmu%2F</url>
    <content type="text"><![CDATA[vue-loader+webpack项目配置1、新建项目文件夹(这里以vueToDo为项目文件夹),在vueToDo文件夹下npm init:这个命令用于创建一个package.json2、安装依赖包 npm install webpack vue vue-loader css-loader vue-template-compiler –save webpack:打包工具vue-loader：vue-loader是一个webpack的loader；可以将vue文件转换为JS模块；css-loader：css-loader使你能够使用类似@import和url（…）的方法实现require的功能vue-template-compiler：可用于将Vue 2.0模板预编译为渲染函数 3、在vueToDo文件夹下新建src文件夹，存放源代码新建app.vue 和 index.js 12345678910111213// index.jsimport Vue from &apos;vue&apos;import App from &apos;./app&apos;const root = document.createElement(&apos;div&apos;)document.body.appendChild(root)new Vue(&#123; render:(h)=&gt;h(App)&#125;).$mount(root)//vue2.0的写法 //render函数是渲染一个视图，然后提供给el挂载，如果没有render那页面什么都不会出来 4、webpack.config.js配置 url-loader:对未设置或者小于limit设置的图片进行转换，以base64的格式被img的src所使用；而对于大于limit byte的图片用file-loader进行解析vue-loader: 可以将vue文件转换为JS模块style-loade: 将css插入到页面的style标签css-loader: 是处理css文件中的url()等file-loader: 作用是移动文件，默认的filename 值是文件内容的md5和原始文件的扩展 另外： less-loader: 是将.less文件编译成css 依赖于less包sass-loader: 是将.sass文件编译成css 依赖于sass包stylus-loader: 是将.styl文件编译成css 依赖于stylus包 5、修改package.json文件，在scripts项添加12345&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config webpack.config.js&quot;, //调用此项目中的webpack,防止与全局webpack版本不一致 &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --mode development --config webpack.config.js&quot;&#125; 6、webpack-dev-server的配置和使用 npm install webpack-dev-server cross-env –savewebpack-dev-server 是一个小型的Node.js Express服务器,它使用webpack-dev-middleware来服务于webpack的包cross-env 能跨平台地设置及使用环境变量 html-webpack-plugin 该插件的两个主要作用1、为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题2、可以生成创建html入口文件，比如单页面可以生成一个html文件入口，配置N个html-webpack-plugin可以生成N个页面入口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//webpack.config.js const path = require(&apos;path&apos;)const HTMLPlugin = require(&apos;html-webpack-plugin&apos;)const webpack = require(&apos;webpack&apos;)const isDev = process.env.NODE_ENV ===&apos;development&apos;const config = &#123; target:&apos;web&apos;, //webpack编译目标是web平台 entry:path.join(__dirname,&apos;src/index.js&apos;), //入口文件 output:&#123; filename:&apos;bundle.js&apos;, //指定打包文件名 path:path.join(__dirname,&apos;dist&apos;) //指定打包文件夹 &#125;, module:&#123; rules:[ &#123; test:/\.vue$/, loader:&apos;vue-loader&apos; &#125;, &#123; test:/\.css$/, use:[ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125;, &#123; test:/\.less/, use:[ &apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos; ] &#125;, &#123; test:/\.styl/, use:[ &apos;style-loader&apos;, &apos;css-loader&apos;, &apos;stylus-loader&apos; ] &#125;, &#123; test:/\.(gif|jpg|png|jpeg|svg)$/, use:[ &#123; loader:&apos;url-loader&apos;, // options:&#123; limit:1024, // name:&apos;[name].[ext]&apos; &#125; &#125; ] &#125; ] &#125;, plugins:[ new webpack.DefinePlugin(&#123; &apos;process.env&apos;:&#123; //根据process.env区分正式版本还是测试版本 NODE_ENV: isDev ? &apos;&quot;development&quot;&apos; : &apos;&quot;production&quot;&apos; &#125; &#125;) new HTMLPlugin() ]&#125;//判断是正式环境，还是开发环境 //devServerif(isDev)&#123; config.devtool = &apos;#cheap-module-eval-source-map&apos; config.devServer=&#123; port:8000, host:&apos;0.0.0.0&apos;, //好处：可以通过公司的内网ip进行访问（如别的电脑或手机上访问） overlay:&#123; //webpack进行编译过程中如果有任何的错误，都让它显示在网页上边，可以很快定位错误 errors:true &#125;, hot:true //热更新 //historyFallback:&#123;&#125; //open: true //每次开启服务器时都会自动 打开浏览器 &#125;&#125;module.exports=config 7、npm install postcss-loader autoprefixer babel-loader babel-core –save 123456789101112131415161718192021222324252627282930313233343536373839404142//postcss.config.jsconst autoprefixer=require(&apos;autoprefixer&apos;)//优化css(需要加浏览器前缀的属性，如：-webkit-)module.exports = &#123; plugins:[ autoprefixer() ]&#125;// .babelrc文件需要 npm install babel-preset-env babel-plugin-transform-vue-jsx --save&#123; &quot;presets&quot;:[ &quot;env&quot; ], &quot;plugins&quot;:[ &quot;transform-vue-jsx&quot; ]&#125;//webpack.config.js 在rules:[]添加&#123; test:/\.jsx$/, loader:&apos;babel-loader&apos;&#125;以处理.jsx文件//css处理文件中添加&#123; test:/\.styl/, use:[ &apos;style-loader&apos;, &apos;css-loader&apos;, &#123; loader:&apos;postcss-loader&apos;, options:&#123; sourceMap:true &#125; &#125;, &apos;stylus-loader&apos; ]&#125; 以上的环境开发环境配置 webpack配置css单独分离打包1、css单独打包 npm install extract-text-webpack-plugin@next –save用@next将插件版本升级到webpack4支持的版本使用extract-text-webpack-plugin插件，将样式文件单独打包，打包输出的文件由配置文件中的output属性指定。然后我们在入口HTML页面写个link标签引入这个打包后的样式文件。 在webpack.config.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//css 中跟据自己需求使用配置css编译，这里只留stylusconst path = require(&apos;path&apos;)const HTMLPlugin = require(&apos;html-webpack-plugin&apos;)const webpack = require(&apos;webpack&apos;)const ExtractPlugin = require(&apos;extract-text-webpack-plugin&apos;) //引入extract-text-webpack-plugin插件const isDev = process.env.NODE_ENV ===&apos;development&apos;const config= &#123; target:&apos;web&apos;, entry:path.join(__dirname,&apos;src/index.js&apos;), //入口文件 output:&#123; filename:&apos;bundle.js&apos;, //指定打包文件名 path:path.join(__dirname,&apos;dist&apos;) //指定打包文件夹 &#125;, module:&#123; rules:[ &#123; test:/\.vue$/, loader:&apos;vue-loader&apos; &#125;, &#123; test:/\.jsx$/, loader:&apos;babel-loader&apos; &#125;, &#123; test:/\.(gif|jpg|png|jpeg|svg)$/, use:[ &#123; loader:&apos;url-loader&apos;, options:&#123; limit:1024, name:&apos;[name].[ext]&apos; &#125; &#125; ] &#125; ] &#125;, plugins:[ new webpack.DefinePlugin(&#123; &apos;process.env&apos;:&#123; NODE_ENV: isDev ? &apos;&quot;development&quot;&apos; : &apos;&quot;production&quot;&apos; &#125; &#125;), new HTMLPlugin() ]&#125;if(isDev)&#123; //开发环境 config.module.rules.push(&#123; test:/\.styl/, use:[ &apos;style-loader&apos;, &apos;css-loader&apos;, &#123; loader:&apos;postcss-loader&apos;, options:&#123; sourceMap:true &#125; &#125;, &apos;stylus-loader&apos; ] &#125;) config.devtool = &apos;#cheap-module-eval-source-map&apos; config.devServer=&#123; port:8000, host:&apos;0.0.0.0&apos;, overlay:&#123; errors:true, &#125;, hot:true &#125; config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() )&#125;module.exports=config]]></content>
      <tags>
        <tag>-vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE-Axios]]></title>
    <url>%2F2017%2F10%2F02%2Fvue-axios%2F</url>
    <content type="text"><![CDATA[Axios1234567891011121314151617181920//npm axios安装npm install axiosimport axios from &apos;axios&apos;Vue.prototype.$http = axios//postthis.$http.post(&apos;getList&apos;,&#123;&apos;user&apos;:123&#125;).then(function(data)&#123; console.log(data);&#125;,function(err)&#123; console.log(err);&#125;)//getthis.$http.get(&apos;getList&apos;).then(function(data)&#123; console.log(data);&#125;,function(err)&#123; console.log(err);&#125;) vue 进行后台数据模拟1、//npm json-server快速“伪造”后台接口一般情况下，网站、APP的数据都需要等待接口人员开发完对应的接口才可以获取到，这样子的效率有点低。最好是我们可以自己模拟接口数据，进行页面的数据填充，打通所有关节，之后等接口开发好了，改下接口地址就好了。 npm install json-server –save 123456789101112131415161718192021222324252627282930313233//在项目根目录下，新建一个 JSON 文件db.json&#123;&quot;getBoardList&quot;: [ &#123; &quot;title&quot;: &quot;开放产品&quot;, &quot;description&quot;: &quot;开放产品是一款开放产品&quot;, &quot;id&quot;: &quot;car&quot;, &quot;toKey&quot;: &quot;analysis&quot;, &quot;saleout&quot;: false &#125;, &#123; &quot;title&quot;: &quot;品牌营销&quot;, &quot;description&quot;: &quot;品牌营销帮助你的产品更好地找到定位&quot;, &quot;id&quot;: &quot;earth&quot;, &quot;toKey&quot;: &quot;count&quot;, &quot;saleout&quot;: false &#125;, &#123; &quot;title&quot;: &quot;使命必达&quot;, &quot;description&quot;: &quot;使命必达快速迭代永远保持最前端的速度&quot;, &quot;id&quot;: &quot;loud&quot;, &quot;toKey&quot;: &quot;forecast&quot;, &quot;saleout&quot;: true &#125;, &#123; &quot;title&quot;: &quot;勇攀高峰&quot;, &quot;description&quot;: &quot;帮你勇闯高峰，到达事业的顶峰&quot;, &quot;id&quot;: &quot;hill&quot;, &quot;toKey&quot;: &quot;publish&quot;, &quot;saleout&quot;: false &#125;]&#125; 12345678910111213141516171819202122232425262728293031//在webpack.dev.conf.js文件中//在这行下 const portfinder = require(&apos;portfinder&apos;)//添加const axios = require(&apos;axios&apos;)const express = require(&apos;express&apos;)const app = express()var appData = require(&apos;../db.json&apos;)//加载本地数据文件var getBoardList = appData.getBoardList //获取对应的本地数据 var apiRoutes = express.Router() app.use(&apos;/api&apos;, apiRoutes) // 调用api找到devServer:添加 before(app) &#123; app.post(&apos;/api/getBoardList&apos;, (req, res) =&gt; &#123; res.json(&#123; errno: 0, data: getBoardList //数据 &#125;) &#125;)&#125;//axios请求数据，代码如下this.$http.post(&apos;/api/getBoardList&apos;).then(function(res)&#123; console.log(res.data.data);&#125;,function(err)&#123; console.log(err);&#125;)]]></content>
      <tags>
        <tag>-vue -axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面布局]]></title>
    <url>%2F2017%2F09%2F06%2Fyemianbuju%2F</url>
    <content type="text"><![CDATA[页面布局的方法一、float：具有局限性，优缺点： 1.脱离文档流 2.兼容性好 3.要清除浮动二、绝对定位：position:absolute;优缺点： 1.脱离文档流 2.快捷，方便三、flexbox布局felxbox布局是css3里新出的一个，它就是为了解决上述两种方式的不足出现的，是比较完美的一个。目前移动端的布局也都是用flexbox。felxbox的缺点就是不能兼容IE8及以下浏览器。四、表格布局表格布局在历史上遭到很多人的摒弃，说表格布局麻烦，操作比较繁琐，其实这是一种误解，在很多场景中，表格布局还是很适用的，比如这个三栏布局，用表格布局就轻易写出来了。还有表格布局的兼容性很好，在flex布局不兼容的时候，可以尝试表格布局。表格布局也是有缺陷的，当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，而有时候这种效果不是我们想要的。五、网格布局网格布局也是新出的一种布局方式，兼容性是一个缺点。1234567891011121314151617181920212223242526272829&lt;style&gt;/*共用样式*/*&#123;margin:0;padding:0;&#125;section&#123;margin-bottom: 15px;&#125;.layout,.layout article div&#123;min-height:100px;&#125;.layout article .left,.layout article .right&#123;width: 300px;background: #333;&#125;.layout article .center&#123;background:#999;&#125;&lt;/style&gt;&lt;p&gt;float-浮动布局&lt;/p&gt;&lt;section class=&quot;layout float&quot;&gt; &lt;style&gt;.layout.float .left&#123;float: left;&#125;.layout.float .right&#123;float: right;&#125;.layout.float .center&#123; margin:0 300px 0 300px;&#125; &lt;/style&gt; &lt;article class=&quot;content&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h3&gt;两侧固定，中间自适应-float&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-float&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-float&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-float&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-float&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-float&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-float&lt;/h3&gt; &lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;p&gt;绝对定位布局&lt;/p&gt;&lt;section class=&quot;layout absolute&quot;&gt; &lt;style&gt; .layout.absolute .content&gt;div&#123;position: absolute;&#125; .layout.absolute .left&#123;left:0;&#125; .layout.absolute .center&#123;left:300px;right:300px;&#125; .layout.absolute .right&#123;right:0;&#125; &lt;/style&gt; &lt;article class=&quot;content&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h3&gt;两侧固定，中间自适应-absolite&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-absolite&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-absolite&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-absolite&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-absolite&lt;/h3&gt; &lt;h3&gt;两侧固定，中间自适应-absolite&lt;/h3&gt; &lt;/div&gt; &lt;/article&gt;&lt;/section&gt;&lt;p&gt;flexbox布局&lt;/p&gt;&lt;section class=&quot;layout flexbox&quot;&gt; &lt;style&gt; .flexbox .content&#123;display: flex;&#125; .flexbox .left&#123;&#125; .flexbox .center&#123;flex:1;&#125; .flexbox .right&#123;&#125; &lt;/style&gt; &lt;article class=&quot;content&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h3&gt;flexbox&lt;/h3&gt; &lt;h3&gt;flexbox&lt;/h3&gt; &lt;h3&gt;flexbox&lt;/h3&gt; &lt;h3&gt;flexbox&lt;/h3&gt; &lt;h3&gt;flexbox&lt;/h3&gt; &lt;h3&gt;flexbox&lt;/h3&gt; &lt;h3&gt;flexbox&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt;&lt;p&gt;table-cell布局&lt;/p&gt;&lt;section class=&quot;layout table&quot;&gt; &lt;style&gt; .layout.table .centent&#123;display:table;width:100%;&#125; .layout.table .centent&gt;div&#123;display: table-cell;&#125; &lt;/style&gt; &lt;article class=&quot;centent&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;p&gt;table&lt;/p&gt; &lt;p&gt;table&lt;/p&gt; &lt;p&gt;table&lt;/p&gt; &lt;p&gt;table&lt;/p&gt; &lt;p&gt;table&lt;/p&gt; &lt;p&gt;table&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt;&lt;p&gt;网格布局&lt;/p&gt;&lt;section class=&quot;layout grid&quot;&gt; &lt;style&gt; .layout.grid .centent&#123; display: grid; width:100%; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; &#125; &lt;/style&gt; &lt;article class=&quot;centent&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;p&gt;grid&lt;/p&gt; &lt;p&gt;grid&lt;/p&gt; &lt;p&gt;grid&lt;/p&gt; &lt;p&gt;grid&lt;/p&gt; &lt;p&gt;grid&lt;/p&gt; &lt;p&gt;grid&lt;/p&gt; &lt;p&gt;grid&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt;]]></content>
      <tags>
        <tag>-css -页面布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-filter()/findIndex()/find()]]></title>
    <url>%2F2017%2F08%2F21%2Fjs-find-findIndex-filter%2F</url>
    <content type="text"><![CDATA[filter()用于把Array的某些元素过滤掉，然后返回剩下的元素。 filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。12345678910111213//例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (x) &#123; return x % 2 !== 0;&#125;)console.log(r) // [1, 5, 9, 15]把一个Array中的空字符串删掉，可以这么写：var arr = [&apos;A&apos;, &apos;&apos;, &apos;B&apos;, null, undefined, &apos;C&apos;, &apos; &apos;];var r = arr.filter(function (s) &#123; return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法&#125;);console.log(r) // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身1234567var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];var r = arr.filter(function (element, index, self) &#123; console.log(element); // 依次打印&apos;A&apos;, &apos;B&apos;, &apos;C&apos; console.log(index); // 依次打印0, 1, 2 console.log(self); // self就是变量arr return true;&#125;); 利用filter，可以巧妙地去除Array的重复元素：123456789&apos;use strict&apos;;var r, arr = [&apos;apple&apos;, &apos;strawberry&apos;, &apos;banana&apos;, &apos;pear&apos;, &apos;apple&apos;, &apos;orange&apos;, &apos;orange&apos;, &apos;strawberry&apos;]; r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index;&#125;);console.log(r.toString());//apple,strawberry,banana,pear,orange//去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了 findIndex(value, index, arr) 返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9; &#125;) // 2 find(value, index, arr) 用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。12345[1, 4, -5, 10].find((n) =&gt; n &lt; 0) // -5 [1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9; &#125;) // 10 findIndex()/find()这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。1234[NaN].indexOf(NaN) // -1 [NaN].findIndex(y =&gt; Object.is(NaN, y)) // 0]]></content>
      <tags>
        <tag>-js -find -findIndex -filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倒计时效果]]></title>
    <url>%2F2017%2F06%2F17%2Fcountdown%2F</url>
    <content type="text"><![CDATA[当前时间 倒计时1 距离设置时间还有天倒计时2 距离设置时间2019/1/1,00:00:00还有 window.onload= function () { showtime(); dao1(); dao2(); } function formatTime(i){ if(i 0 ){ document.getElementById('dao1').innerHTML = daytime; } } //倒计时1 //倒计时2 function dao2(){ let nowtime = new Date(); let endtime = new Date("2019/1/1,00:00:00"); let time = parseInt((endtime.getTime() - nowtime.getTime())/1000);//秒 let d = parseInt(time/(24*60*60)); let h = parseInt(time/(60*60)%24); let m = parseInt(time/60%60); let s = parseInt(time%60); m = formatTime(m); s = formatTime(s); document.getElementById('dao2').innerHTML = d+'天'+h+'时'+m+'分'+s+'秒'; setTimeout(dao2,500) } 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;p&gt;当前时间&lt;/p&gt;&lt;div id="time"&gt;&lt;/div&gt;&lt;p&gt;倒计时1&lt;/p&gt;&lt;div class="dao1"&gt;距离设置时间还有&lt;span id="dao1"&gt;&lt;/span&gt;天&lt;/div&gt;&lt;p&gt;倒计时2&lt;/p&gt;&lt;div class="dao2"&gt;距离设置时间2019/1/1,00:00:00还有&lt;span id="dao2"&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; window.onload= function () &#123; showtime(); dao1(); dao2(); &#125; function formatTime(i)&#123; if(i&lt;10)&#123; i='0'+i; &#125; return i; &#125; //当前时间 function showtime()&#123; let myDate = new Date(); let year = myDate.getFullYear();//年 let month = myDate.getMonth();//月 let date = myDate.getDate();//日 let day = myDate.getDay();//星期 let h = myDate.getHours();//时 let m = myDate.getMinutes();//分 let s = myDate.getSeconds();//秒 m = formatTime(m); s = formatTime(s); let time=document.getElementById("time"); let weekday = ['星期日','星期一','星期二','星期三','星期四','星期五','星期六',''] time.innerHTML=year+'年'+month+'月'+date+'日 '+weekday[day]+' '+h+':'+m+':'+s; setTimeout(showtime,500); &#125; //当前时间 //倒计时1 function dao1()&#123; let curtime = new Date(); let endtime = new Date("2019,1,1"); let time = endtime.getTime() - curtime.getTime();//getTime()毫秒 //1000 * 60 * 60 * 24一天的秒数 //利用Math.ceil()对象方法，对得出的时间差进行向上取整。 //parseInt()取整。 daytime = parseInt(time/(1000 * 60 * 60 * 24)) if(daytime &gt; 0 )&#123; document.getElementById('dao1').innerHTML = daytime; &#125; &#125; //倒计时1 //倒计时2 function dao2()&#123; let nowtime = new Date(); let endtime = new Date("2019/1/1,00:00:00"); let time = parseInt((endtime.getTime() - nowtime.getTime())/1000);//秒 let d = parseInt(time/(24*60*60)); let h = parseInt(time/(60*60)%24); let m = parseInt(time/60%60); let s = parseInt(time%60); m = formatTime(m); s = formatTime(s); document.getElementById('dao2').innerHTML = d+'天'+h+'时'+m+'分'+s+'秒'; setTimeout(dao2,500) &#125; //倒计时2&lt;/script&gt;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端自动化项目构建]]></title>
    <url>%2F2017%2F06%2F03%2Fqianduanzidonghua%2F</url>
    <content type="text"><![CDATA[前端自动化项目构建这里的编译环境是 gulp + webpack + node + express + express-generator1、gulp就是解决自动化构建，增强工作流程的一个工具2、webpack 用来将各种文件（js，css，图片之类）进行打包的工具3、express nodejs 的 web 服务器4、express-generator nodejs 的 web 服务器的初始化工具备注：不一定要使用这种方式来实现自动刷新环境搭建，这个只是其中一个举例。 开始构建 node 安装不详细说了，官网上下载就是了(win.msi/macOS.pkg)。npm会随它一起安装。https://nodejs.org//zh-cn/download 1、新建项目目录project2、在项目文件夹下创建app、server、tasks3、目录结构如下： 1234567891011app // 这是放置前端代码目录├── css //放置css文件├── js //放置js文件| ├──index.js //初始化一个入口文件| ├──class| | └──test.js|── views //放置html文件| ├──error.ejs //初始化错误模板| └──index.ejs //初始化入口模板server // 服务器tasks //构建工具目录 4、进入server文件夹，执行 express -e . 它会创建一些文件夹和文件并提示你去安装依赖关系， 执行npm install5、安装完成后进入到构建目录tasks创建文件夹util并新建文件args.js 通过使用 yargs 这个模块来处理命令行的参数，主要是方便处理命令行参数的捕获和过滤。官方地址 12tasks //构建工具目录├──args.js //初始化一个入口文件 6、进入项目根目录project后，初始化项目目录的 npm 环境 执行npm init 会自动创建package.json文件，它是安装依赖包必须的。 1234567891011121314151617181920212223242526272829303132333435This utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help json` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt;` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.package name: (project) //项目名称-可不填会有默认version: (1.0.0) 1.0.1 //版本-可不填会有默认description: //可不填直接回车entry point: (index.js)//可不填直接回车test command://可不填直接回车git repository://可不填直接回车keywords://可不填直接回车author://可不填直接回车license: (ISC)//可不填直接回车About to write to E:\project\package.json:&#123; &quot;name&quot;: &quot;project&quot;, &quot;version&quot;: &quot;1.0.1&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125;Is this ok? (yes) y 7、创建.babelrc文件 babel的配置文件，这里需要配置 presets，是为了编译 es6语法的。win7以上的系统已经提供了一种命名方法: 我们只需在重命名时写 .babelrc.{注意开头和结尾一共有两个点}这里需要装个包：npm install babel-preset-es2015 –save-dev 123&#123; &quot;presets&quot;:[&quot;es2015&quot;]&#125; 8、创建gulpfile.babel.js文件 gulpfile.babel.js //es6语法用这个文件，固定的；不加.babel会有报错gulpfile.js是 gulp 的默认配置文件 9、打开第5步创建的args.js文件，编辑123456789101112131415161718192021222324252627282930313233import yargs from &apos;yargs&apos;;const args = yargs .option(&apos;production&apos;, &#123; boolean: true, default: false, describe: &apos;min all scripts&apos; &#125;) .option(&apos;watch&apos;, &#123; // watch 参数 boolean: true, default: false, describe: &apos;watch all files&apos; &#125;) .option(&apos;verbose&apos;, &#123; boolean: true, default: false, describe: &apos;log&apos; &#125;) .option(&apos;sourcemaps&apos;, &#123; describe: &apos;force the creation of sroucemaps&apos; &#125;) .option(&apos;port&apos;, &#123; string: true, default: 8080, describe: &apos;server port&apos; &#125;) .argv // 会返回对象，里面有之前配置的参数export default args; 10、在tasks文件夹下创建构建脚本script.js,对js做处理（构建脚本一定要放在tasks文件夹下） 回到根目录下安装这些引用的包：npm install gulp gulp-if gulp-concat webpack webpack-stream vinyl-named gulp-livereload gulp-plumber gulp-rename gulp-uglify gulp-util yargs –save-dev 123456789101112131415161718192021222324252627282930313233343536373839404142import gulp from &apos;gulp&apos;;//引入gulp 自动化构建工具import gulpif from &apos;gulp-if&apos;;//gulp 语句中作if判断import concat from &apos;gulp-concat&apos;;//gulp 中处理文件拼接import webpack from &apos;webpack&apos;;//打包工具import gulpWebpack from &apos;webpack-stream&apos;;// webpack使用时需要附带上import named from &apos;vinyl-named&apos;;//对文件重命名，作标记import livereload from &apos;gulp-livereload&apos;;//热更新，自动刷新import plumber from &apos;gulp-plumber&apos;;//处理文件信息流,防止来自 gulp 插件错误导致中断操作的插件import rename from &apos;gulp-rename&apos;;//对文件重命名import uglify from &apos;gulp-uglify&apos;;//处理压缩js/cssimport &#123;log,colors&#125; from &apos;gulp-util&apos;;//在命令行输出的包 (色彩、log)import args from &apos;./util/args&apos;;//对命令行参数进行解析的包gulp.task(&apos;scripts&apos;,()=&gt;&#123;//gulp创建一个名为script的任务 return gulp.src([&apos;app/js/index.js&apos;]) .pipe(plumber(&#123; // 将错误通过errorHandle输出 errorHandle:function()&#123; &#125; &#125;)) .pipe(named())//vinyl-named用来保持输入和输出的文件名相同, 否则会自动生成一个hash. .pipe(gulpWebpack(&#123;// 使用 webpack 对 js 文件通过 babel 进行转义 module:&#123;// 这是 webpack 的调用模块写法 loaders:[&#123; test:/\.js$/, loader:&apos;babel-loader&apos;// 使用 babel loader,这是个包需要安装 &#125;] &#125; &#125;),null,(err,stats)=&gt;&#123; log(`Finished &apos;$&#123;colors.cyan(&apos;scripts&apos;)&#125;&apos;`,stats.toString(&#123; chunks:false &#125;)) &#125;) .pipe(gulp.dest(&apos;server/public/js&apos;))// 输出处理后的 js 文件 .pipe(rename(&#123;// 重命名，这里是对 js 文件压缩后的文件命名 basename:&apos;cp&apos;, extname:&apos;.min.js&apos; &#125;)) .pipe(uglify(&#123;compress:&#123;properties:false&#125;,output:&#123;&apos;quote_keys&apos;:true&#125;&#125;)) // 压缩文件 .pipe(gulp.dest(&apos;server/public/js&apos;))// 重新输出处理后的 js 文件 .pipe(gulpif(args.watch,livereload()))// watch 监听文件并自动刷新&#125;) 11、创建处理模板的构建脚本，在tasks文件夹下创建构建脚本pages.js 12345678910import gulp from &apos;gulp&apos;;//引入gulp 自动化构建工具import gulpif from &apos;gulp-if&apos;;//gulp 语句中作if判断import livereload from &apos;gulp-livereload&apos;;//热更新，自动刷新import args from &apos;./util/args&apos;;//对命令行参数进行解析的包gulp.task(&apos;pages&apos;,()=&gt;&#123; return gulp.src(&apos;app/**/*.ejs&apos;) .pipe(gulp.dest(&apos;server&apos;)) .pipe(gulpif(args.watch,livereload()))&#125;) 12、服务器相关脚本,在tasks文件夹下创建构建脚本server.js 这里引入了一个新的包，npm install gulp-live-server –save -dev 12345678910111213141516171819import gulp from &apos;gulp&apos;;//引入gulp 自动化构建工具import gulpif from &apos;gulp-if&apos;;//gulp 语句中作if判断import liveserver from &apos;gulp-live-server&apos; //起动作为服务器的包import args from &apos;./util/args&apos;;//对命令行参数进行解析的包gulp.task(&apos;serve&apos;,(cb)=&gt;&#123; if(!args.watch) return cb(); var server = liveserver.new([&apos;--harmony&apos;,&apos;server/bin/www&apos;]); server.start(); gulp.watch([&apos;server/public/**/*.js&apos;,&apos;server/views/**/*.ejs&apos;],function(file)&#123; server.notify.apply(server,[file]); &#125;) gulp.watch([&apos;server/routes/**/*.js&apos;,&apos;server/app.js&apos;],function () &#123; server.start.bind(server)() &#125;);&#125;) 13、在tasks文件夹下创建构建脚本css.js 负责处理 css 文件编译的，这里并没有做更多的 css 编译处理，css 编译通常有 less，sass等，需要借助不同的插件来处理，不过这里只是直接输出，所以不作介绍。 12345678910import gulp from &apos;gulp&apos;;//引入gulp 自动化构建工具import gulpif from &apos;gulp-if&apos;;//gulp 语句中作if判断import livereload from &apos;gulp-livereload&apos;;//热更新，自动刷新import args from &apos;./util/args&apos;;//对命令行参数进行解析的包gulp.task(&apos;css&apos;,()=&gt;&#123; return gulp.src(&apos;app/**/*.css&apos;) // 将源文件复制到目标目录 .pipe(gulp.dest(&apos;server/public&apos;)) .pipe(gulpif(args.watch,livereload()))&#125;) 14、在tasks文件夹下创建构建脚本browser.js 这个文件主要就是负责监听源代码的变化，然后将变化的内容分别通知不同的任务进行处理，这是真正的实现文件监听的任务。这里引入了一个新的包，npm install gulp-util–save-dev 1234567891011121314import gulp from &apos;gulp&apos;;//引入gulp 自动化构建工具import gulpif from &apos;gulp-if&apos;;//gulp 语句中作if判断import gutil from &apos;gulp-util&apos;;import args from &apos;./util/args&apos;;//对命令行参数进行解析的包gulp.task(&apos;browser&apos;,(cb)=&gt;&#123; if(!args.watch) return cb(); // 监听 js 文件变化 gulp.watch(&apos;app/**/*.js&apos;,[&apos;scripts&apos;]); // 监听 ejs 文件变化 gulp.watch(&apos;app/**/*.ejs&apos;,[&apos;pages&apos;]); // 监听 css 文件变化 gulp.watch(&apos;app/**/*.css&apos;,[&apos;css&apos;]);&#125;) 15、每次编译都需要清空原来的文件。所以在tasks文件夹下创建构建脚本clean.js 这里引入了一个新的包，npm install del –save-dev 1234567import gulp from &apos;gulp&apos;;import del from &apos;del&apos;;// 如果在这个任务里面没有命令行参数的话，也可以不导入import args from &apos;./util/args&apos;; gulp.task(&apos;clean&apos;,()=&gt;&#123; // 使用 es6语法做函数写法 return del([&apos;server/public&apos;,&apos;server/views&apos;]) // 清空2个目录的文件&#125;) 16、同样在tasks文件夹下创建构建脚本build.js 这里就是真的 build 脚本任务文件了，这里使用了一个特殊包gulp-sequence，负责安排脚本执行的顺序的。npm install gulp-sequence –save-dev 1234import gulp from &apos;gulp&apos;;//引入gulp 自动化构建工具import gulpSequence from &apos;gulp-sequence&apos;;// 处理包的顺序问题// 用中括号的意思是任务是平行的，不存在先后gulp.task(&apos;build&apos;,gulpSequence(&apos;clean&apos;,&apos;css&apos;,&apos;pages&apos;,&apos;scripts&apos;,[&apos;browser&apos;,&apos;serve&apos;])) 17、default.js 这是 gulp的默认的，首先执行的任务脚本文件，从这里出发，扩散到其他任务脚本。 12import gulp from &apos;gulp&apos;;//引入gulp 自动化构建工具gulp.task(&apos;default&apos;,[&apos;build&apos;]); 这个时这时如果运行gulp，会提示错误，因为上面涉及到几个包没有安装 npm install babel-loader babel-core babel-preset-env –save-dev 别忘记gulpfile.babel.js里没写东西呢 又引入了新的包：npm install require-dir –save-dev123import requireDir from &apos;require-dir&apos;;requireDir(&apos;./tasks&apos;); 可以尽情的去跑起来了。。。还差最后两个地方1、记得不你的模板里还是空的app/views/index.ejs 记得加上HTML内容2、server/app.js 又一个新包，接收热更新：npm install connect-livereload –save-dev 12app.use(express.static(path.join(__dirname, &apos;public&apos;)));app.use(require(&apos;connect-livereload&apos;)());//新加的能接收热更新的包一定要放在上一行的下面 至此终于完了，学于幕课网gulp –watch浏览器打开：localhost:3000]]></content>
      <tags>
        <tag>前端自动化项目构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-解构赋值]]></title>
    <url>%2F2017%2F05%2F08%2Fjiegoufuzhi%2F</url>
    <content type="text"><![CDATA[解构赋值语法是一个 Javascript 表达式，这使得可以将值从数组或属性从对象提取到不同的变量中。说的很抽象，看代码吧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//数组&#123; let a,b,rest; [a,b]=[1,2]; console.log(a,b);//1,2&#125;&#123; let a,b,rest; [a,b,...rest]=[1,2,3,4,5,6] console.log(a,b,rest);//1,2,[3,4,5,6]&#125;//对象&#123; let a,b; (&#123;a,b&#125;=&#123;a:1,b:2&#125;); console.log(a,b);//1,2&#125;&#123; let a,b,c,rest; [a,b,c=3]=[1,2]; console.log(a,b,c);//1,2,3&#125;&#123; let a,b,c,rest; [a:A,b]=[1,2]; console.log(A,b,a);//1,2,undefined //a被重命名为A,a就是相当于键名&#125;&#123; let a,b,c,rest; [a,b,c]=[1,2]; console.log(a,b,c);//1,2,undefined&#125;//应用场景&#123; //变量的交换 let a=1; let b=2; [a,b]=[b,a]; console.log(a,b);//2,1&#125;&#123; function f() &#123; return [1,2] &#125; let a,b; [a,b]=f(); console.log(a,b);//1,2&#125;&#123; function f() &#123; return [1,2,3,4,5]; &#125; let a,b,c; [a,,,b]=f(); console.log(a,b);//1,4&#125;&#123; function f() &#123; return [1,2,3,4,5]; &#125; let a,b,c; [a,,...b]=f(); console.log(a,b);//1,[3,4,5] c=f(); console.log(c);//[1,2,3,4,5]&#125;&#123; let o=&#123;p:42,q:true&#125;; let &#123;p,q&#125;=o; console.log(o[&apos;p&apos;]+&quot;,&quot;+o[&quot;q&quot;]) console.log(p,q);&#125;&#123; let &#123;a=10,b=5&#125;=&#123;a:3&#125;; console.log(a,b);//3,5&#125;&#123; let metaData=&#123; title:&apos;abc&apos;, test:[&#123; title:&apos;test&apos;, desc:&apos;descripttion&apos; &#125;] &#125; let &#123;title:esTitle,test:[&#123;title:cnTitle&#125;]&#125;=metaData; console.log(esTitle,cnTitle);//abc,test&#125;&#123; //解构数据 let res = &#123; status:200, id:12, data:[&#123;name:&apos;bob&apos;&#125;,&#123;name:&apos;lee&apos;&#125;] &#125; let &#123;statue,id,data&#125;= res; if(statue == 200)&#123; ... &#125; &#125;&#123; //解构方法 let &#123;floor,pow&#125;=Math; let a = 1.1; console.log(floor(a))//1&#125;&#123; let arr = [1,2]//传参有顺序问题 function test1([a,b])&#123; console.log(&quot;a:&quot;,a); console.log(&quot;b:&quot;,b); &#125; test1(arr); let obj = &#123;b:2,a:1&#125;//传参可不受顺序限制 function test(&#123;a=10,b&#125;)&#123; console.log(&quot;a:&quot;,a); console.log(&quot;b:&quot;,b); &#125; test(obj);&#125;]]></content>
      <tags>
        <tag>-js -解构赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除浮动的方法]]></title>
    <url>%2F2017%2F05%2F06%2Fqingchufudong%2F</url>
    <content type="text"><![CDATA[1、结尾处加空div标签 clear:both;原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度优点：简单、代码少、浏览器支持好、不容易出现怪问题缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法 2、父级div定义 伪类:after 和 zoom原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。建议：推荐使用，建议定义公共类，以减少CSS代码。12345678/*清除浮动*/.clearfix:before,.clearfix:after &#123; content: &quot;&quot;; display: table;&#125;.clearfix:after &#123; clear: both;&#125; 3、父级div定义 overflow:hidden原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度优点：简单、代码少、浏览器支持好缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。4、父级div定义 display:flow-root;很遗憾，只有最火狐53+，chrome58+，opera45+，才支持。不过未来，应该都会支持吧。我们也可以用@supports(display:flow-root){}来进行优雅降级处理。或者用@@supports not (display:flow-root){}来进行渐进增强处理。]]></content>
      <tags>
        <tag>-css -clear</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-set-map]]></title>
    <url>%2F2017%2F05%2F05%2Fes6-set-map%2F</url>
    <content type="text"><![CDATA[setES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。开发中用于去除重复数据Set 本身是一个构造函数，用来生成 Set 数据结构。 123456const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 Set 方法 1、新建new Set([‘…’])2、获取个数.size3、添加add、删除delete、是否包含has、清除clear4、keys和values都是相等的5、类似于数组没有重复的元素（唯一的） 12345678let s=new Set([1,2,3,3]);console.log(&quot;arr:&quot;,arr) // 返回1,2,3 去除重复数据s.add(4).add(4) // 注意4被加入了两次s.delete(2)console.log(&quot;s:&quot;,s.has(4)) // trueconsole.log(&quot;s:&quot;,s.keys())console.log(&quot;s:&quot;,s.values())s.clear() 下面是一个对比，看看在判断是否包括一个键上面，Object结构和Set结构的写法不同。 123456789101112131415// 对象的写法const properties = &#123; &apos;width&apos;: 1, &apos;height&apos;: 1&#125;;if (properties[someName]) &#123; // do something&#125;// Set的写法const properties = new Set();properties.add(&apos;width&apos;);properties.add(&apos;height&apos;);if (properties.has(someName)) &#123; // do something&#125; Array.from方法可以将 Set 结构转为数组。 12const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items); 这就提供了去除数组重复成员的另一种方法。 12345function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] 遍历操作 Set 结构的实例有四个遍历方法，可以用于遍历成员。 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 12345678910111213141516171819202122let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;] 直接用for…of循环遍历 Set。 1234567let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);for (let x of set) &#123; console.log(x);&#125;// red// green// blue forEach方法，用于对每个成员执行某种操作，没有返回值。 12345set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + &apos; : &apos; + value))// 1 : 1// 4 : 4// 9 : 9 mapES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。1、新建new Map([])2、 size:属性返回 Map 结构的成员总数 set(key, value):添加一个新建元素到映射。 get(key):返回映射中的指定元素。 has(key):如果映射包含指定元素，则返回 true。 delete(key):从映射中移除指定的元素。 clear:从映射中移除所有元素。 forEach:对映射中的每个元素执行指定操作。 toString:返回映射的字符串表示形式。 valueOf:返回指定对象的原始值。12345678910111213141516171819const map = new Map([ [&apos;name&apos;,&apos;leepeng&apos;], [&apos;age&apos;,24], [&apos;sex&apos;,&apos;男&apos;], [obj1,&apos;sfsfdsfe&apos;], [obj2,&apos;lihfksdnsiu&apos;], [[1,2,3],&apos;haha&apos;]])map.set(&apos;friends&apos;,[&apos;ffff&apos;,&apos;gggg&apos;])console.log(map.size)console.log(map)console.log(map.get(&apos;name&apos;))console.log(map.delete(&apos;name&apos;))console.log(map.has(&apos;age&apos;))//map.clear();console.log(map)map.forEach(function (value,index) &#123; console.log(index+&apos;:&apos;+value)&#125;) 遍历方法 Map 结构原生提供三个遍历器生成函数和一个遍历方法。keys()：返回键名的遍历器。values()：返回键值的遍历器。entries()：返回所有成员的遍历器。forEach()：遍历 Map 的所有成员。需要特别注意的是，Map 的遍历顺序就是插入顺序。 123456789101112131415161718192021222324252627282930313233343536const map = new Map([ [&apos;F&apos;, &apos;no&apos;], [&apos;T&apos;, &apos;yes&apos;],]);for (let key of map.keys()) &#123; console.log(key);&#125;// &quot;F&quot;// &quot;T&quot;for (let value of map.values()) &#123; console.log(value);&#125;// &quot;no&quot;// &quot;yes&quot;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot; Map 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。1234567891011121314map.forEach(function(value, key, map) &#123; console.log(&quot;Key: %s, Value: %s&quot;, key, value);&#125;);forEach方法还可以接受第二个参数，用来绑定this。const reporter = &#123; report: function(key, value) &#123; console.log(&quot;Key: %s, Value: %s&quot;, key, value); &#125;&#125;;map.forEach(function(value, key, map) &#123; this.report(key, value);&#125;, reporter); 上面代码中，forEach方法的回调函数的this，就指向reporter。 与其他数据结构的互相转换 （1）Map 转为数组前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（…）。12345const myMap = new Map() .set(true, 7) .set(&#123;foo: 3&#125;, [&apos;abc&apos;]);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &apos;abc&apos; ] ] ] （2）数组 转为 Map将数组传入 Map 构造函数，就可以转为 Map。12345678new Map([ [true, 7], [&#123;foo: 3&#125;, [&apos;abc&apos;]]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]// &#125; （3）Map 转为对象如果所有 Map 的键都是字符串，它可以转为对象。12345678910111213function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map() .set(&apos;yes&apos;, true) .set(&apos;no&apos;, false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; （4）对象转为 Map12345678910function objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125; （5）Map 转为 JSONMap 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。1234567function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);strMapToJson(myMap)// &apos;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&apos; 另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。1234567function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);mapToArrayJson(myMap)// &apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos; （6）JSON 转为 MapJSON 转为 Map，正常情况下，所有键名都是字符串。123456function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap(&apos;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&apos;)// Map &#123;&apos;yes&apos; =&gt; true, &apos;no&apos; =&gt; false&#125; 但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是数组转为 JSON 的逆操作。123456function jsonToMap(jsonStr) &#123; return new Map(JSON.parse(jsonStr));&#125;jsonToMap(&apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;)// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]&#125;]]></content>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-let,const]]></title>
    <url>%2F2017%2F05%2F04%2Fes6-lensson1%2F</url>
    <content type="text"><![CDATA[let命令1、let命令， 用来声明变量。 它的用法类似于var， 但是所声明的变量， 只在let命令所在的代码块内有效。2、变量一定要在声明后使用， 否则报错。3、使用let命令声明变量之前， 该变量都是不可用的。4、变量x使用let命令声明， 所以在声明之前， 都属于x的“死区”， 只要用到该变量就会报错。 因此， typeof运行时就会抛出一个ReferenceError。5、let不允许在相同作用域内， 重复声明同一个变量。123456&#123; let a = 10; var b = 1;&#125; console.log(a) // ReferenceError: a is not defined.console.log(b) // 1 for循环的计数器，很适合使用let12for(let i =0;i&lt; arr.length;i++ )&#123;&#125;console.log(i) // ReferenceError: a is not defined. const 命令1、const声明一个只读的常量。 一旦声明， 常量的值就不能改变。（ eg 1 ）2、const声明的变量不得改变值， 这意味着， const一旦声明变量， 就必须立即初始化， 不能留到以后赋值。3、const的作用域与let命令相同： 只在声明所在的块级作用域内有效。4、const命令声明的常量也是不提升， 同样存在暂时性死区， 只能在声明的位置后面使用。123const PI = 3.1415;PI // 3.1415PI = 3; // TypeError: Assignment to constant variable.对于复合类型的变量， 变量名不指向数据， 而是指向数据所在的地址。const命令只是保证变量名指向的地址不变， 并不保证该地址的数据不变， 所以将一个对象声明为常量必须非常小心。12345const foo = &#123;&#125;;foo.prop = 123;foo.prop// 123foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only 上面代码中， 常量foo储存的是一个地址， 这个地址指向一个对象。 不可变的只是这个地址， 即不能把foo指向另一个地址， 但对象本身是可变的， 所以依然可以为其添加新属性。]]></content>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老是忘记的小问题!]]></title>
    <url>%2F2017%2F05%2F02%2Fwangjidexiaowenti%2F</url>
    <content type="text"><![CDATA[1、火狐FF里INPUT标签刷新页面后 仍然保存之前输入的内容。 直接在input 标签里 增加 autocomplete=”off”。火狐默认为 on。]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[屏蔽双击选中文字的方法!]]></title>
    <url>%2F2017%2F05%2F02%2Fpingbishuangjixuanzhongzi%2F</url>
    <content type="text"><![CDATA[屏蔽双击选中文字的方法! onselectstart=”return false”（直接加在需要作用的标签） eg: &lt;div class=”test” onselectstart=”return false” style=”-moz-user-select:none;” &gt;你选不到我。。。（屏蔽双击选中文字的区域）&lt;/div&gt; 如果你在标签里加了onselectstart=”return false” 那标签内的文字都没法选中了。。 css禁止双击页面选中文本 user-select：none | text | all | element默认值：text适用于：除替换元素外的所有元素继承性：无动画性：否计算值：指定值取值：none：文本不能被选择text：可以选择文本all：当所有内容作为一个整体时可以被选择。如果双击或者在上下文上点击子元素，那么被选择的部分将是以该子元素向上回溯的最高祖先元素。element：可以选择文本，但选择范围受元素边界的约束]]></content>
      <tags>
        <tag>js</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap在模态框里加载iframe页面（iframe里的关闭按钮）的时候如何关闭模态框]]></title>
    <url>%2F2017%2F05%2F02%2Fbootstrap-addiframe-close-modal%2F</url>
    <content type="text"><![CDATA[bootstrap在模态框里加载iframe页面（iframe里的关闭按钮）的时候如何关闭模态框window.parent.$(‘#myModal’).modal(‘hide’);eg:window.self功能：是对当前窗口自身的引用。它和window属性是等价的。语法：window.self注：window、self、window.self是等价的。 window.top功能：返回顶层窗口，即浏览器窗口。语法：window.top注：如果窗口本身就是顶层窗口，top属性返回的是对自身的引用。 window.parent功能：返回父窗口。语法：window.parent注：如果窗口本身是顶层窗口，parent属性返回的是对自身的引用。在框架网页中，一般父窗口就是顶层窗口，但如果框架中还有框架，父窗口和顶层窗口就不一定相同了。 判断当前窗口是否在一个框架中： &lt; script type=”text/JavaScript” &gt;var b = window.top!=window.self;document.write( “当前窗口是否在一个框架中：”+b );&lt; /script &gt;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML-&#65279导致页面顶部空白一行]]></title>
    <url>%2F2017%2F04%2F20%2Fhtml-kongbai%2F</url>
    <content type="text"><![CDATA[HTML-&amp;#65279导致页面顶部空白一行 静态html页面，在浏览器中测试的时候，发现其中一个html页面的顶部多出了些许空白，而另一个页面显示正常。在浏览器中进行了审查对比，发现有空白的那个页面的head标签里面的元素全部跑到了body里面，而且body中还多出了一个，当把这个东西删除之后就正常了。然后又在编辑器中，对比了一下这两个页面的源码，发现head部分完全一样，body中的代码也没有什么异常。最后通过查阅相关资料，才发现原来是编码的问题。页面的编码如果是UTF-8 + BOM，会在body开头处加入一个可见的控制符，导致页面头部会出现一个空白。这种编码方式一般会在windows操作系统中出现，比如记事本编辑器，在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。但对于html来说，BOM是个大麻烦。因为浏览器在解析html页面时，并不会忽略BOM，所以在解析html文件时，会把BOM作为该文件开头正文的一部分，这串字符也将会被直接执行（在页面中并不显示）出来。由此造成即使页面的 top或者padding 设置为0，也无法让整个网页紧贴浏览器顶部，因为在html一开头有这3个隐藏字符！]]></content>
      <tags>
        <tag>html</tag>
        <tag>小问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to LeePeng’s blog! 我是李鹏，web前端 &amp; 设计师。音乐重度依赖患者，设计师强迫症患者，书买得比看得多患者，毒舌患者，间歇性感伤患者，习惯性熬夜患者。]]></content>
  </entry>
</search>
